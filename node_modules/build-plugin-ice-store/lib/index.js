"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var chalk = require("chalk");
var generator_1 = require("./generator");
var checkStoreExists_1 = require("./utils/checkStoreExists");
var getPath_1 = require("./utils/getPath");
var getFileType_1 = require("./utils/getFileType");
var vitePluginPageRedirect_1 = require("./vitePluginPageRedirect");
var pluginName = require('../package.json').name;
exports.default = (function (api) { return __awaiter(void 0, void 0, void 0, function () {
    var context, getValue, onHook, applyMethod, onGetWebpackConfig, modifyUserConfig, rootDir, userConfig, isMpa, entry, store, swc, alias, vite, router, _a, babelPlugins, tempPath, srcDir, srcPath, tempDir, pagesName, storeExists, appStoreFile, configPath, projectType, routesPaths, routes, replacePathBabelPlugin, loadableBabelPluginIndex, gen;
    return __generator(this, function (_b) {
        context = api.context, getValue = api.getValue, onHook = api.onHook, applyMethod = api.applyMethod, onGetWebpackConfig = api.onGetWebpackConfig, modifyUserConfig = api.modifyUserConfig;
        rootDir = context.rootDir, userConfig = context.userConfig;
        isMpa = userConfig.mpa, entry = userConfig.entry, store = userConfig.store, swc = userConfig.swc, alias = userConfig.alias, vite = userConfig.vite, router = userConfig.router, _a = userConfig.babelPlugins, babelPlugins = _a === void 0 ? [] : _a;
        tempPath = getValue('TEMP_PATH');
        srcDir = isMpa ? 'src' : applyMethod('getSourceDir', entry);
        srcPath = path.join(rootDir, srcDir);
        tempDir = (path.basename(tempPath) || '');
        pagesName = applyMethod('getPages', srcPath);
        storeExists = (0, checkStoreExists_1.default)(srcPath, pagesName);
        if (!storeExists) {
            onHook('before.start.run', function () {
                applyMethod('watchFileChange', /store.*/, function (event, filePath) {
                    if (event === 'add') {
                        // restart WDS
                        console.log('\n');
                        console.log(chalk.magenta(filePath + " has been created"));
                        console.log(chalk.magenta('restart dev server'));
                        process.send({ type: 'RESTART_DEV' });
                    }
                });
            });
            applyMethod('addDisableRuntimePlugin', pluginName);
            return [2 /*return*/];
        }
        appStoreFile = applyMethod('formatPath', (0, getPath_1.getAppStorePath)(srcPath));
        applyMethod('addExport', {
            source: '@ice/store',
            specifier: '{ createStore }',
            exportName: 'createStore',
            importSource: '@ice/store',
            exportMembers: ['createStore'],
        });
        if (!appStoreFile) {
            // set IStore to IAppConfig
            applyMethod('addAppConfigTypes', { source: '../plugins/store/types', specifier: '{ IStore }', exportName: 'store?: IStore' });
        }
        configPath = (router || {}).configPath;
        projectType = getValue('PROJECT_TYPE');
        if (isMpa) {
            routesPaths = pagesName.map(function (pageName) {
                var pagePath = path.join(rootDir, 'src', 'pages', pageName);
                var routesFileType = (0, getFileType_1.getRouteFileType)(pagePath);
                return path.join(pagePath, "routes" + routesFileType);
            });
        }
        else {
            routes = applyMethod('getRoutes', {
                rootDir: rootDir,
                tempPath: tempPath,
                configPath: configPath,
                projectType: projectType,
                isMpa: isMpa,
                srcDir: srcDir
            });
            routesPaths = [routes.routesPath];
        }
        // add vite plugin for redirect page component
        if (vite) {
            modifyUserConfig('vite.plugins', [(0, vitePluginPageRedirect_1.default)(rootDir, routesPaths)], { deepmerge: true });
        }
        if (swc) {
            onGetWebpackConfig(function (config) {
                config.module
                    .rule('replace-router-path')
                    // ensure that replace-router-path-loader is before babel-loader
                    // @loadable/babel-plugin will transform the router paths which replace-router-path-loader couldn't transform
                    .before('babel-loader')
                    .test(function (filePath) { return routesPaths.includes(filePath); })
                    .use('replace-router-path-loader')
                    .loader(require.resolve(path.join(__dirname, 'replacePathLoader')))
                    .options({
                    alias: alias,
                    tempDir: tempDir,
                    applyMethod: applyMethod,
                    routesPaths: routesPaths,
                    rootDir: rootDir,
                    srcPath: srcPath
                });
            });
        }
        else {
            replacePathBabelPlugin = [
                require.resolve('./babelPluginReplacePath'),
                {
                    routesPaths: routesPaths,
                    alias: alias,
                    applyMethod: applyMethod,
                    tempDir: tempDir,
                    rootDir: rootDir
                }
            ];
            loadableBabelPluginIndex = babelPlugins.indexOf('@loadable/babel-plugin');
            if (loadableBabelPluginIndex > -1) {
                // ensure ReplacePathBabelPlugin is before @loadable/babel-plugin
                // @loadable/babel-plugin will transform the router paths which babelPluginReplacePath couldn't transform
                babelPlugins.splice(loadableBabelPluginIndex, 0, replacePathBabelPlugin);
            }
            else {
                babelPlugins.push(replacePathBabelPlugin);
            }
            modifyUserConfig('babelPlugins', __spreadArray([], babelPlugins, true));
        }
        onGetWebpackConfig(function (config) {
            config.resolve.alias.set('$store', appStoreFile || path.join(tempPath, 'plugins', 'store', 'index.ts'));
            if (config.get('cache')) {
                config.merge({
                    cache: {
                        type: 'filesystem',
                        version: getValue('WEBPACK_CACHE_ID') + "&store=true"
                    }
                });
            }
        });
        gen = new generator_1.default({
            tempPath: tempPath,
            applyMethod: applyMethod,
            srcPath: srcPath,
            disableResetPageState: !!(store === null || store === void 0 ? void 0 : store.disableResetPageState)
        });
        gen.render();
        onHook('before.start.run', function () {
            applyMethod('watchFileChange', /models\/.*|model.*|store.*|pages\/\w+\/index(.jsx?|.tsx)/, function (event) {
                if (event === 'add' || event === 'unlink') {
                    gen.render(true);
                }
            });
        });
        return [2 /*return*/];
    });
}); });
//# sourceMappingURL=index.js.map