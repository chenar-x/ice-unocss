"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint @typescript-eslint/no-var-requires:0, no-shadow: 0 */
var path = require("path");
var fse = require("fs-extra");
var assert = require("assert");
var glob = require("glob");
var bodyParser = require("body-parser");
var chokidar = require("chokidar");
var multer = require("multer");
var debounce = require("lodash.debounce");
var analyzeMockDeps_1 = require("./analyzeMockDeps");
var matchPath_1 = require("./matchPath");
var debug = require('debug')('ice:mock');
var chalk = require('chalk');
var OPTIONAL_METHODS = ['get', 'post', 'put', 'patch', 'delete'];
var winPath = function (path) {
    return path.replace(/\\/g, '/');
};
var error = null;
var cwd = process.cwd();
var mockDir = winPath(path.join(cwd, 'mock'));
function getConfig(rootDir, ignore) {
    // get mock files
    var mockFiles = glob.sync('mock/**/*.[jt]s', {
        cwd: rootDir,
        ignore: ignore,
    }).map(function (file) { return path.join(rootDir, file); });
    var requireDeps = mockFiles.reduce(function (pre, curr) {
        return pre.concat((0, analyzeMockDeps_1.default)(curr));
    }, []);
    var onlySet = Array.from(new Set(__spreadArray(__spreadArray([], requireDeps, true), mockFiles, true)));
    // set @babel/register for node's require
    // eslint-disable-next-line global-require
    require('@babel/register')({
        presets: [require.resolve('./babelPresetNode')],
        ignore: [/node_modules/],
        only: onlySet,
        extensions: ['.js', '.ts'],
        babelrc: false,
        cache: false,
    });
    var mockConfig = {};
    mockFiles.forEach(function (mockFile) {
        if (fse.existsSync(mockFile)) {
            // disable require cache
            Object.keys(require.cache).forEach(function (file) {
                var winPathFile = winPath(file);
                if (winPathFile === mockFile || winPathFile.indexOf(mockDir) > -1) {
                    debug("delete cache " + file);
                    delete require.cache[file];
                }
            });
            try {
                // eslint-disable-next-line import/no-dynamic-require, global-require
                var mockModule = require(mockFile);
                var mockData = mockModule.default || mockModule || {};
                Object.assign(mockConfig, mockData);
            }
            catch (err) {
                console.log(err);
            }
        }
    });
    return mockConfig;
}
var watchFiles = {};
function logWatchFile(event, filePath) {
    // won't log message when initialize
    if (watchFiles[filePath]) {
        console.log(chalk.green(event.toUpperCase()), filePath.replace(cwd, '.'));
    }
    else {
        watchFiles[filePath] = true;
    }
}
function applyMock(app, ignore) {
    if (ignore === void 0) { ignore = []; }
    try {
        realApplyMock(app, ignore);
        error = null;
    }
    catch (e) {
        console.log(e);
        error = e;
        console.log();
        outputError();
        var watcher_1 = chokidar.watch([mockDir], {
            ignored: /node_modules/,
            ignoreInitial: true,
        });
        watcher_1.on('all', function (event, path) {
            logWatchFile(event, path);
            watcher_1.close();
            applyMock(app, ignore);
        });
    }
}
function realApplyMock(app, ignore) {
    var mockConfig = [];
    function parseMockConfig() {
        var parsedMockConfig = [];
        var config = getConfig(cwd, ignore);
        Object.keys(config).forEach(function (key) {
            var handler = config[key];
            assert(typeof handler === 'function' ||
                typeof handler === 'object' ||
                typeof handler === 'string', "mock value of " + key + " should be function or object or string, but got " + typeof handler);
            Array.prototype.push.apply(parsedMockConfig, parseConfig(key, handler));
        });
        return parsedMockConfig;
    }
    mockConfig = parseMockConfig();
    var watcher = chokidar.watch([mockDir], {
        ignored: /node_modules/,
        persistent: true,
    });
    // use debounce to avoid too much file change events
    var updateMockConfig = debounce(function () {
        mockConfig = parseMockConfig();
    }, 300);
    watcher.on('all', function (event, path) {
        logWatchFile(event, path);
        updateMockConfig();
    });
    app.use(function (req, res, next) {
        var match = mockConfig.length && (0, matchPath_1.default)(req, mockConfig);
        if (match) {
            debug("mock matched: [" + match.method + "] " + match.path);
            return match.handler(req, res, next);
        }
        else {
            return next();
        }
    });
}
function parseConfig(key, handler) {
    var method = 'get';
    var path = key;
    if (key.indexOf(' ') > -1) {
        var splited = key.split(' ');
        method = splited[0].toLowerCase();
        path = splited[1];
        return [
            {
                method: method,
                path: path,
                handler: createHandler(method, path, handler),
                key: key,
            },
        ];
    }
    return OPTIONAL_METHODS.map(function (method) { return ({
        method: method,
        path: path,
        handler: createHandler(method, path, handler),
        key: key,
    }); });
}
function createHandler(method, path, handler) {
    return function (req, res, next) {
        // get method do not to bodyParser
        var bodyParserMethods = OPTIONAL_METHODS.filter(function (method) { return method !== 'get'; });
        if (bodyParserMethods.includes(method)) {
            bodyParser.json({ limit: '5mb', strict: false })(req, res, function () {
                bodyParser.urlencoded({ limit: '5mb', extended: true })(req, res, function () {
                    sendData();
                });
            });
        }
        else {
            sendData();
        }
        function sendData() {
            if (typeof handler === 'function') {
                // deal with multipart/form-data
                // https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md
                multer().any()(req, res, function () {
                    handler(req, res, next);
                });
            }
            else if (res.json) {
                res.json(handler);
            }
            else {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(handler));
            }
        }
    };
}
function outputError() {
    if (!error)
        return;
    var filePath = error.message.split(': ')[0];
    var relativeFilePath = filePath.replace(cwd, '.');
    var errors = error.stack
        .split('\n')
        .filter(function (line) { return line.trim().indexOf('at ') !== 0; })
        .map(function (line) { return line.replace(filePath + ": ", ''); });
    errors.splice(1, 0, ['']);
    console.log(chalk.red('Failed to parse mock config.'));
    console.log();
    console.log("Error in " + relativeFilePath);
    console.log(errors.join('\n'));
    console.log();
}
module.exports = applyMock;
//# sourceMappingURL=index.js.map