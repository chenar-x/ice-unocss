"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Routes = exports.IceRouter = exports.parseRoutes = void 0;
/* eslint @typescript-eslint/explicit-function-return-type:0, react/jsx-filename-extension: 0, no-shadow: 0, @typescript-eslint/no-explicit-any:0 */
var React = require("react");
var react_1 = require("react");
var react_router_dom_1 = require("react-router-dom");
var component_1 = require("@loadable/component");
function wrapperRoute(component, routerWrappers) {
    return (routerWrappers || []).reduce(function (acc, curr) {
        var compose = curr(acc);
        if (acc.pageConfig) {
            compose.pageConfig = acc.pageConfig;
        }
        if (acc.getInitialProps) {
            compose.getInitialProps = acc.getInitialProps;
        }
        return compose;
    }, component);
}
function setComponentAttr(comp, route) {
    if (!route)
        return;
    ['pageConfig', 'getInitialProps'].forEach(function (attr) {
        if (Object.prototype.hasOwnProperty.call(route, attr)) {
            comp[attr] = route[attr];
        }
    });
}
function getRouteComponent(component, routerWrappers, route, fallback) {
    var _a = component || {}, __LAZY__ = _a.__LAZY__, dynamicImport = _a.dynamicImport, __LOADABLE__ = _a.__LOADABLE__;
    if (__LOADABLE__) {
        return (0, component_1.default)(dynamicImport, {
            resolveComponent: function (mod) {
                var comp = mod.default;
                // 适配中心化路由配置（react-loadable）
                setComponentAttr(comp, route);
                return wrapperRoute(comp, routerWrappers);
            },
            fallback: fallback
        });
    }
    else if (__LAZY__) {
        return (0, react_1.lazy)(function () { return dynamicImport().then(function (mod) {
            if (routerWrappers && routerWrappers.length) {
                var comp = mod.default;
                // 适配中心化路由配置（React lazy）
                setComponentAttr(comp, route);
                return __assign(__assign({}, mod), { default: wrapperRoute(comp, routerWrappers) });
            }
            return mod;
        }); });
    }
    else {
        // 适配中心化路由配置（非按需加载）
        setComponentAttr(component, route);
        return wrapperRoute(component, routerWrappers);
    }
}
function parseRoutes(routes, fallback) {
    return routes.map(function (route) {
        var children = route.children, component = route.component, routeWrappers = route.routeWrappers, wrappers = route.wrappers, others = __rest(route, ["children", "component", "routeWrappers", "wrappers"]);
        // do not wrapper components to layout added by runtime api wrapperPageComponent
        var mergedRouteWrappers = children ? [] : routeWrappers;
        if (wrappers && wrappers.length) {
            mergedRouteWrappers = mergedRouteWrappers.concat(wrappers);
        }
        var parsedRoute = __assign({}, others);
        if (component) {
            parsedRoute.component = getRouteComponent(component, mergedRouteWrappers, route, fallback);
        }
        if (children) {
            parsedRoute.children = parseRoutes(children, fallback);
        }
        return parsedRoute;
    });
}
exports.parseRoutes = parseRoutes;
function IceRouter(props) {
    var type = props.type, children = props.children, others = __rest(props, ["type", "children"]);
    var renderChildren = children;
    if (!renderChildren && props.routes) {
        // parse routes before render
        var parsedRoutes = parseRoutes(props.routes, props.fallback);
        renderChildren = React.createElement(Routes, { routes: parsedRoutes, fallback: props.fallback });
    }
    return type === 'static' ?
        React.createElement(react_router_dom_1.StaticRouter, __assign({}, others), renderChildren) :
        React.createElement(react_router_dom_1.Router, __assign({}, others), renderChildren);
}
exports.IceRouter = IceRouter;
function Routes(_a) {
    var routes = _a.routes, fallback = _a.fallback;
    return (React.createElement(react_router_dom_1.Switch, null, routes.map(function (route, id) {
        var children = route.children;
        if (!children) {
            if (route.redirect) {
                var redirect = route.redirect, others = __rest(route, ["redirect"]);
                return React.createElement(react_router_dom_1.Redirect, __assign({ key: id, from: route.path, to: redirect }, others));
            }
            else {
                var RouteComponent_1 = route.component, others = __rest(route, ["component"]);
                if (RouteComponent_1) {
                    // React does not currently support Suspense when components are being server-side rendered
                    // process.env.__IS_SERVER__: React.RenderToString()
                    // window.__ICE_SSR_ENABLED__: React.hydrate()
                    var RenderComponent = process.env.__IS_SERVER__ || window.__ICE_SSR_ENABLED__
                        ? function (props) { return React.createElement(RouteComponent_1, __assign({}, props)); }
                        : function (props) {
                            return (React.createElement(react_1.Suspense, { fallback: fallback || React.createElement("div", null, "loading") },
                                React.createElement(RouteComponent_1, __assign({}, props))));
                        };
                    return (React.createElement(react_router_dom_1.Route, __assign({ key: id }, others, { render: RenderComponent })));
                }
                else {
                    console.error('[Router] component is required when config routes');
                    return null;
                }
            }
        }
        else {
            var LayoutComponent_1 = route.component, children_1 = route.children, others = __rest(route, ["component", "children"]);
            var routesComponent_1 = React.createElement(Routes, { routes: children_1, fallback: fallback });
            var RenderComponent = function (props) { return LayoutComponent_1 ? (React.createElement(LayoutComponent_1, __assign({}, props), routesComponent_1)) : routesComponent_1; };
            return (React.createElement(react_router_dom_1.Route, __assign({ key: id }, others, { render: RenderComponent })));
        }
    })));
}
exports.Routes = Routes;
//# sourceMappingURL=Router.js.map