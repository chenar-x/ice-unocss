"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var fse = require("fs-extra");
var globby = require("globby");
var formatPath_1 = require("./formatPath");
var formatPluginDir_1 = require("./formatPluginDir");
//  https://regexr.com/47jlq
var importRegex = /import\s+?(?:(?:(?:[\w*\s{},]*)\s+from\s+?)|)(?:(?:"(.*?)")|(?:'(.*?)'))[\s]*?(?:;|$|)/;
exports.default = (function (plugins, targetDir, hasJsxRuntime) {
    if (plugins === void 0) { plugins = []; }
    var analyzeMap = new Set();
    var sourceCache = new Map();
    function removeReactStatement(sourceCode) {
        var replacedCode = sourceCode;
        // match: import React from 'react'; import * as React from 'react';
        var defaultImportRegex = /([\w\W]*)?(\n?import\s+(?:\*\s+as\s+)?React\s+from\s+['"]react['"];?\n?)([\w\W]*)/;
        // match: import React, { useState } from 'react';
        var namedImport = /([\w\W]*import\s+(?:[\w*\s{}]*)?\s?)(,?\s?React\s?,?\s?){1}((?:[\w*\s{}]*)?\s+from\s+['"]react['"];?[\w\W]*)/;
        var matched = false;
        var replacer = function (match, p1, p2, p3) {
            if (p2) {
                matched = true;
                return "" + (p1 || '') + (p3 || '');
            }
            return match;
        };
        replacedCode = replacedCode.replace(defaultImportRegex, replacer);
        if (!matched) {
            replacedCode = replacedCode.replace(namedImport, replacer);
        }
        return replacedCode;
    }
    function analyzeRelativePath(filePath, relativeFiles) {
        var source = fse.readFileSync(filePath, 'utf-8');
        sourceCache.set(filePath, source);
        var matches = source.match(new RegExp(importRegex, 'g'));
        var imports = [];
        if (matches) {
            imports = matches.map(function (matchStr) {
                var _a = matchStr.match(importRegex), singleQuoteImporter = _a[1], doubleQuoteImporter = _a[2];
                var importer = singleQuoteImporter || doubleQuoteImporter;
                // compatible with `import xx from '.';`
                return importer === '.' ? './index' : importer;
            }).filter(Boolean);
        }
        imports.forEach(function (importName) {
            if (importName.startsWith('.')) {
                var importPath = (0, formatPath_1.default)(path.join(path.dirname(filePath), importName));
                var importFile = globby.sync(path.extname(importPath) ? importPath : [importPath + ".@((t|j)s?(x))", importPath + "/index.@((t|j)s?(x))"]);
                if (importFile.length > 0) {
                    relativeFiles.push(importFile[0]);
                    if (!analyzeMap.has(importFile[0])) {
                        analyzeMap.add(importFile[0]);
                        analyzeRelativePath(importFile[0], relativeFiles);
                    }
                }
                else {
                    throw new Error("can not find module " + importName);
                }
            }
        });
    }
    return plugins.map(function (_a) {
        var pluginPath = _a.pluginPath, name = _a.name;
        // compatible with function plugin
        if (!pluginPath)
            return false;
        // NOTE: module.js will be discarded in future.
        var pluginDir = path.dirname(pluginPath);
        // compatible with output file extension of .jsx
        var absoluteModulePath = globby.sync('runtime.@((t|j)s?(x))', { cwd: pluginDir, absolute: true })[0];
        var modulePath = absoluteModulePath;
        var moduleDir = path.join(pluginDir, '..');
        if (!absoluteModulePath) {
            // filter plugin without runtime
            return false;
        }
        else if (name) {
            // copy module dir to target dir
            var tempDir_1 = path.join(targetDir, 'plugins', (0, formatPluginDir_1.default)(name), 'pluginRuntime');
            // ensure source dir
            var srcDir = path.join(moduleDir, 'src');
            if (fse.existsSync(srcDir)) {
                var runtimePaths = globby.sync('runtime.@((t|j)s?(x))', { cwd: srcDir });
                if (runtimePaths.length > 0) {
                    var runtimeFilePath_1 = path.join(srcDir, runtimePaths[0]);
                    var relativeFiles = [];
                    analyzeRelativePath(runtimeFilePath_1, relativeFiles);
                    // copy source code when runtime exists
                    __spreadArray([runtimeFilePath_1], relativeFiles, true).forEach(function (filePath) {
                        var targetPath = '';
                        if (filePath !== runtimeFilePath_1) {
                            targetPath = path.join(tempDir_1, path.relative(path.dirname(runtimeFilePath_1), path.dirname(filePath)), path.basename(filePath));
                        }
                        else {
                            targetPath = path.join(tempDir_1, path.basename(runtimeFilePath_1));
                        }
                        fse.ensureDirSync(path.dirname(targetPath));
                        if (hasJsxRuntime) {
                            // remove React import when jsx runtime is enabled
                            var sourceCode = removeReactStatement(sourceCache.get(filePath) || fse.readFileSync(filePath, 'utf8'));
                            fse.writeFileSync(targetPath, sourceCode);
                        }
                        else {
                            fse.copySync(filePath, targetPath);
                        }
                    });
                    absoluteModulePath = path.join(tempDir_1, runtimePaths[0]).replace(/.(t|j)(s|sx)$/, '');
                    modulePath = "../" + path.relative(targetDir, absoluteModulePath);
                }
            }
        }
        // read package.json
        var pluginConfig = {};
        var pkgPath = path.join(moduleDir, 'package.json');
        try {
            pluginConfig = fse.readJSONSync(pkgPath).pluginConfig;
        }
        catch (error) {
            console.log("ERROR: fail to load package.json of plugin " + name);
        }
        return {
            pluginConfig: pluginConfig,
            modulePath: (0, formatPath_1.default)(modulePath),
            absoluteModulePath: (0, formatPath_1.default)(absoluteModulePath),
            name: name,
        };
    })
        .filter(Boolean)
        .map(function (_a) {
        var modulePath = _a.modulePath, pluginConfig = _a.pluginConfig, name = _a.name, absoluteModulePath = _a.absoluteModulePath;
        var staticModule = (pluginConfig && pluginConfig.staticModule) || false;
        return {
            staticModule: staticModule,
            path: modulePath,
            absoluteModulePath: absoluteModulePath,
            name: name,
        };
    });
});
//# sourceMappingURL=getRuntimeModules.js.map