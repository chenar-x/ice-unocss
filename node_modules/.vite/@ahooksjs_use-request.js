import {
  require_react
} from "./chunk-CX2VL6PA.js";
import {
  __commonJS,
  __toModule
} from "./chunk-YYC2CZC2.js";

// node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = debounce2;
  }
});

// node_modules/lodash.throttle/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.throttle/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle2(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce2(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = throttle2;
  }
});

// node_modules/@ahooksjs/use-request/es/index.js
var import_react7 = __toModule(require_react());

// node_modules/@ahooksjs/use-request/es/useAsync.js
var import_lodash = __toModule(require_lodash());
var import_lodash2 = __toModule(require_lodash2());
var import_react3 = __toModule(require_react());

// node_modules/@ahooksjs/use-request/es/utils/utils.js
function isDocumentVisible() {
  if (typeof document !== "undefined" && typeof document.visibilityState !== "undefined") {
    return document.visibilityState !== "hidden";
  }
  return true;
}
function isOnline() {
  if (typeof navigator.onLine !== "undefined") {
    return navigator.onLine;
  }
  return true;
}

// node_modules/@ahooksjs/use-request/es/utils/cache.js
var cache = new Map();
var setCache = function setCache2(key, cacheTime, data) {
  var currentCache = cache.get(key);
  if (currentCache === null || currentCache === void 0 ? void 0 : currentCache.timer) {
    clearTimeout(currentCache.timer);
  }
  var timer = void 0;
  if (cacheTime > -1) {
    timer = setTimeout(function() {
      cache["delete"](key);
    }, cacheTime);
  }
  cache.set(key, {
    data,
    timer,
    startTime: new Date().getTime()
  });
};
var getCache = function getCache2(key) {
  var currentCache = cache.get(key);
  return {
    data: currentCache === null || currentCache === void 0 ? void 0 : currentCache.data,
    startTime: currentCache === null || currentCache === void 0 ? void 0 : currentCache.startTime
  };
};

// node_modules/@ahooksjs/use-request/es/utils/limit.js
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spread = function() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }
  return ar;
};
function limit(fn, timespan) {
  var pending = false;
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (pending)
      return;
    pending = true;
    fn.apply(void 0, __spread(args));
    setTimeout(function() {
      pending = false;
    }, timespan);
  };
}

// node_modules/@ahooksjs/use-request/es/utils/usePersistFn.js
var import_react = __toModule(require_react());
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spread2 = function() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read2(arguments[i]));
  }
  return ar;
};
function usePersistFn(fn) {
  var ref = (0, import_react.useRef)(function() {
    throw new Error("Cannot call an event handler while rendering.");
  });
  ref.current = fn;
  var persist = (0, import_react.useCallback)(function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var refFn = ref.current;
    if (refFn) {
      return refFn.apply(void 0, __spread2(args));
    }
  }, [ref]);
  if (typeof fn === "function") {
    return persist;
  }
  return void 0;
}
var usePersistFn_default = usePersistFn;

// node_modules/@ahooksjs/use-request/es/utils/useUpdateEffect.js
var import_react2 = __toModule(require_react());
var useUpdateEffect = function useUpdateEffect2(effect, deps) {
  var isMounted = (0, import_react2.useRef)(false);
  (0, import_react2.useEffect)(function() {
    return function() {
      isMounted.current = false;
    };
  }, []);
  (0, import_react2.useEffect)(function() {
    if (!isMounted.current) {
      isMounted.current = true;
    } else {
      return effect();
    }
  }, deps);
};
var useUpdateEffect_default = useUpdateEffect;

// node_modules/@ahooksjs/use-request/es/utils/windowFocus.js
var listeners = [];
function subscribe(listener) {
  listeners.push(listener);
  return function unsubscribe() {
    var index = listeners.indexOf(listener);
    listeners.splice(index, 1);
  };
}
var eventsBinded = false;
if (typeof window !== "undefined" && window.addEventListener && !eventsBinded) {
  revalidate = function revalidate2() {
    if (!isDocumentVisible() || !isOnline())
      return;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }
  };
  window.addEventListener("visibilitychange", revalidate, false);
  window.addEventListener("focus", revalidate, false);
  eventsBinded = true;
}
var revalidate;
var windowFocus_default = subscribe;

// node_modules/@ahooksjs/use-request/es/utils/windowVisible.js
var listeners2 = [];
function subscribe2(listener) {
  listeners2.push(listener);
  return function unsubscribe() {
    var index = listeners2.indexOf(listener);
    listeners2.splice(index, 1);
  };
}
var eventsBinded2 = false;
if (typeof window !== "undefined" && window.addEventListener && !eventsBinded2) {
  revalidate = function revalidate2() {
    if (!isDocumentVisible())
      return;
    for (var i = 0; i < listeners2.length; i++) {
      var listener = listeners2[i];
      listener();
    }
  };
  window.addEventListener("visibilitychange", revalidate, false);
  eventsBinded2 = true;
}
var revalidate;
var windowVisible_default = subscribe2;

// node_modules/@ahooksjs/use-request/es/useAsync.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __read3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spread3 = function() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read3(arguments[i]));
  }
  return ar;
};
var DEFAULT_KEY = "AHOOKS_USE_REQUEST_DEFAULT_KEY";
var Fetch = function() {
  function Fetch2(service, config, subscribe3, initState) {
    this.count = 0;
    this.pollingWhenVisibleFlag = false;
    this.pollingTimer = void 0;
    this.loadingDelayTimer = void 0;
    this.unsubscribe = [];
    this.that = this;
    this.state = {
      loading: false,
      params: [],
      data: void 0,
      error: void 0,
      run: this.run.bind(this.that),
      mutate: this.mutate.bind(this.that),
      refresh: this.refresh.bind(this.that),
      cancel: this.cancel.bind(this.that),
      unmount: this.unmount.bind(this.that)
    };
    this.service = service;
    this.config = config;
    this.subscribe = subscribe3;
    if (initState) {
      this.state = __assign(__assign({}, this.state), initState);
    }
    this.debounceRun = this.config.debounceInterval ? (0, import_lodash.default)(this._run, this.config.debounceInterval) : void 0;
    this.throttleRun = this.config.throttleInterval ? (0, import_lodash2.default)(this._run, this.config.throttleInterval) : void 0;
    this.limitRefresh = limit(this.refresh.bind(this), this.config.focusTimespan);
    if (this.config.pollingInterval) {
      this.unsubscribe.push(windowVisible_default(this.rePolling.bind(this)));
    }
    if (this.config.refreshOnWindowFocus) {
      this.unsubscribe.push(windowFocus_default(this.limitRefresh.bind(this)));
    }
  }
  Fetch2.prototype.setState = function(s) {
    if (s === void 0) {
      s = {};
    }
    this.state = __assign(__assign({}, this.state), s);
    this.subscribe(this.state);
  };
  Fetch2.prototype._run = function() {
    var _this = this;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.pollingTimer) {
      clearTimeout(this.pollingTimer);
    }
    if (this.loadingDelayTimer) {
      clearTimeout(this.loadingDelayTimer);
    }
    this.count += 1;
    var currentCount = this.count;
    this.setState({
      loading: !this.config.loadingDelay,
      params: args
    });
    if (this.config.loadingDelay) {
      this.loadingDelayTimer = setTimeout(function() {
        _this.setState({
          loading: true
        });
      }, this.config.loadingDelay);
    }
    return this.service.apply(this, __spread3(args)).then(function(res) {
      if (currentCount !== _this.count) {
        return new Promise(function() {
        });
      }
      if (_this.loadingDelayTimer) {
        clearTimeout(_this.loadingDelayTimer);
      }
      var formattedResult = _this.config.formatResult ? _this.config.formatResult(res) : res;
      _this.setState({
        data: formattedResult,
        error: void 0,
        loading: false
      });
      if (_this.config.onSuccess) {
        _this.config.onSuccess(formattedResult, args);
      }
      return formattedResult;
    })["catch"](function(error) {
      if (currentCount !== _this.count) {
        return new Promise(function() {
        });
      }
      if (_this.loadingDelayTimer) {
        clearTimeout(_this.loadingDelayTimer);
      }
      _this.setState({
        data: void 0,
        error,
        loading: false
      });
      if (_this.config.onError) {
        _this.config.onError(error, args);
      }
      if (_this.config.throwOnError) {
        throw error;
      }
      console.error(error);
      return Promise.reject("useRequest has caught the exception, if you need to handle the exception yourself, you can set options.throwOnError to true.");
    })["finally"](function() {
      if (currentCount === _this.count) {
        if (_this.config.pollingInterval) {
          if (!isDocumentVisible() && !_this.config.pollingWhenHidden) {
            _this.pollingWhenVisibleFlag = true;
            return;
          }
          _this.pollingTimer = setTimeout(function() {
            _this._run.apply(_this, __spread3(args));
          }, _this.config.pollingInterval);
        }
      }
    });
  };
  Fetch2.prototype.run = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.debounceRun) {
      this.debounceRun.apply(this, __spread3(args));
      return Promise.resolve(null);
    }
    if (this.throttleRun) {
      this.throttleRun.apply(this, __spread3(args));
      return Promise.resolve(null);
    }
    return this._run.apply(this, __spread3(args));
  };
  Fetch2.prototype.cancel = function() {
    if (this.debounceRun) {
      this.debounceRun.cancel();
    }
    if (this.throttleRun) {
      this.throttleRun.cancel();
    }
    if (this.loadingDelayTimer) {
      clearTimeout(this.loadingDelayTimer);
    }
    if (this.pollingTimer) {
      clearTimeout(this.pollingTimer);
    }
    this.pollingWhenVisibleFlag = false;
    this.count += 1;
    this.setState({
      loading: false
    });
  };
  Fetch2.prototype.refresh = function() {
    return this.run.apply(this, __spread3(this.state.params));
  };
  Fetch2.prototype.rePolling = function() {
    if (this.pollingWhenVisibleFlag) {
      this.pollingWhenVisibleFlag = false;
      this.refresh();
    }
  };
  Fetch2.prototype.mutate = function(data) {
    if (typeof data === "function") {
      this.setState({
        data: data(this.state.data) || {}
      });
    } else {
      this.setState({
        data
      });
    }
  };
  Fetch2.prototype.unmount = function() {
    this.cancel();
    this.unsubscribe.forEach(function(s) {
      s();
    });
  };
  return Fetch2;
}();
function useAsync(service, options) {
  var _options = options || {};
  var _a = _options.refreshDeps, refreshDeps = _a === void 0 ? [] : _a, _b = _options.manual, manual = _b === void 0 ? false : _b, _c = _options.onSuccess, onSuccess = _c === void 0 ? function() {
  } : _c, _d = _options.onError, onError = _d === void 0 ? function() {
  } : _d, _e = _options.defaultLoading, defaultLoading = _e === void 0 ? false : _e, loadingDelay = _options.loadingDelay, _f = _options.pollingInterval, pollingInterval = _f === void 0 ? 0 : _f, _g = _options.pollingWhenHidden, pollingWhenHidden = _g === void 0 ? true : _g, _h = _options.defaultParams, defaultParams = _h === void 0 ? [] : _h, _j = _options.refreshOnWindowFocus, refreshOnWindowFocus = _j === void 0 ? false : _j, _k = _options.focusTimespan, focusTimespan = _k === void 0 ? 5e3 : _k, fetchKey = _options.fetchKey, cacheKey = _options.cacheKey, _l = _options.cacheTime, cacheTime = _l === void 0 ? 5 * 60 * 1e3 : _l, _m = _options.staleTime, staleTime = _m === void 0 ? 0 : _m, debounceInterval = _options.debounceInterval, throttleInterval = _options.throttleInterval, initialData = _options.initialData, _o = _options.ready, ready = _o === void 0 ? true : _o, _p = _options.throwOnError, throwOnError = _p === void 0 ? false : _p;
  var newstFetchKey = (0, import_react3.useRef)(DEFAULT_KEY);
  var servicePersist = usePersistFn_default(service);
  var onSuccessPersist = usePersistFn_default(onSuccess);
  var onErrorPersist = usePersistFn_default(onError);
  var fetchKeyPersist = usePersistFn_default(fetchKey);
  var formatResult;
  if ("formatResult" in _options) {
    formatResult = _options.formatResult;
  }
  var formatResultPersist = usePersistFn_default(formatResult);
  var config = {
    formatResult: formatResultPersist,
    onSuccess: onSuccessPersist,
    onError: onErrorPersist,
    loadingDelay,
    pollingInterval,
    pollingWhenHidden,
    refreshOnWindowFocus: !manual && refreshOnWindowFocus,
    focusTimespan,
    debounceInterval,
    throttleInterval,
    throwOnError
  };
  var subscribe3 = usePersistFn_default(function(key, data) {
    setFetches(function(s) {
      s[key] = data;
      return __assign({}, s);
    });
  });
  var _q = __read3((0, import_react3.useState)(function() {
    var _a2;
    if (cacheKey) {
      var cacheData_1 = (_a2 = getCache(cacheKey)) === null || _a2 === void 0 ? void 0 : _a2.data;
      if (cacheData_1) {
        newstFetchKey.current = cacheData_1.newstFetchKey;
        var newFetches_1 = {};
        Object.keys(cacheData_1.fetches).forEach(function(key) {
          var cacheFetch = cacheData_1.fetches[key];
          var newFetch = new Fetch(servicePersist, config, subscribe3.bind(null, key), {
            loading: cacheFetch.loading,
            params: cacheFetch.params,
            data: cacheFetch.data,
            error: cacheFetch.error
          });
          newFetches_1[key] = newFetch.state;
        });
        return newFetches_1;
      }
    }
    return {};
  }), 2), fetches = _q[0], setFetches = _q[1];
  var fetchesRef = (0, import_react3.useRef)(fetches);
  fetchesRef.current = fetches;
  var readyMemoryParams = (0, import_react3.useRef)();
  var run = (0, import_react3.useCallback)(function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!ready) {
      readyMemoryParams.current = args;
      return;
    }
    if (fetchKeyPersist) {
      var key = fetchKeyPersist.apply(void 0, __spread3(args));
      newstFetchKey.current = key === void 0 ? DEFAULT_KEY : key;
    }
    var currentFetchKey = newstFetchKey.current;
    var currentFetch = fetchesRef.current[currentFetchKey];
    if (!currentFetch) {
      var newFetch = new Fetch(servicePersist, config, subscribe3.bind(null, currentFetchKey), {
        data: initialData
      });
      currentFetch = newFetch.state;
      setFetches(function(s) {
        s[currentFetchKey] = currentFetch;
        return __assign({}, s);
      });
    }
    return currentFetch.run.apply(currentFetch, __spread3(args));
  }, [fetchKey, subscribe3, ready]);
  var runRef = (0, import_react3.useRef)(run);
  runRef.current = run;
  useUpdateEffect_default(function() {
    if (cacheKey) {
      setCache(cacheKey, cacheTime, {
        fetches,
        newstFetchKey: newstFetchKey.current
      });
    }
  }, [cacheKey, fetches]);
  var hasTriggeredByReady = (0, import_react3.useRef)(false);
  useUpdateEffect_default(function() {
    if (ready) {
      if (!hasTriggeredByReady.current && readyMemoryParams.current) {
        runRef.current.apply(runRef, __spread3(readyMemoryParams.current));
      }
      hasTriggeredByReady.current = true;
    }
  }, [ready]);
  (0, import_react3.useEffect)(function() {
    var _a2;
    if (!manual) {
      if (Object.keys(fetches).length > 0) {
        var cacheStartTime = cacheKey && ((_a2 = getCache(cacheKey)) === null || _a2 === void 0 ? void 0 : _a2.startTime) || 0;
        if (!(staleTime === -1 || new Date().getTime() - cacheStartTime <= staleTime)) {
          Object.values(fetches).forEach(function(f) {
            f.refresh();
          });
        }
      } else {
        runRef.current.apply(runRef, __spread3(defaultParams));
      }
    }
  }, []);
  var reset = (0, import_react3.useCallback)(function() {
    Object.values(fetchesRef.current).forEach(function(f) {
      f.unmount();
    });
    newstFetchKey.current = DEFAULT_KEY;
    setFetches({});
    fetchesRef.current = {};
  }, [setFetches]);
  useUpdateEffect_default(function() {
    if (!manual) {
      Object.values(fetchesRef.current).forEach(function(f) {
        f.refresh();
      });
    }
  }, __spread3(refreshDeps));
  (0, import_react3.useEffect)(function() {
    return function() {
      Object.values(fetchesRef.current).forEach(function(f) {
        f.unmount();
      });
    };
  }, []);
  var notExecutedWarning = (0, import_react3.useCallback)(function(name) {
    return function() {
      console.warn("You should't call " + name + " when service not executed once.");
    };
  }, []);
  return __assign(__assign({
    loading: ready && !manual || defaultLoading,
    data: initialData,
    error: void 0,
    params: [],
    cancel: notExecutedWarning("cancel"),
    refresh: notExecutedWarning("refresh"),
    mutate: notExecutedWarning("mutate")
  }, fetches[newstFetchKey.current] || {}), {
    run,
    fetches,
    reset
  });
}
var useAsync_default = useAsync;

// node_modules/@ahooksjs/use-request/es/useLoadMore.js
var import_react4 = __toModule(require_react());
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __read4 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spread4 = function() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read4(arguments[i]));
  }
  return ar;
};
function useLoadMore(service, options) {
  var _a = options.refreshDeps, refreshDeps = _a === void 0 ? [] : _a, ref = options.ref, isNoMore = options.isNoMore, _b = options.threshold, threshold = _b === void 0 ? 100 : _b, fetchKey = options.fetchKey, restOptions = __rest(options, ["refreshDeps", "ref", "isNoMore", "threshold", "fetchKey"]);
  var _c = __read4((0, import_react4.useState)(false), 2), loadingMore = _c[0], setLoadingMore = _c[1];
  (0, import_react4.useEffect)(function() {
    if (options.fetchKey) {
      console.warn("useRequest loadMore mode don't need fetchKey!");
    }
  }, []);
  var result = useAsync_default(service, __assign2(__assign2({}, restOptions), {
    fetchKey: function fetchKey2(d) {
      var _a2;
      return ((_a2 = d === null || d === void 0 ? void 0 : d.list) === null || _a2 === void 0 ? void 0 : _a2.length) || 0;
    },
    onSuccess: function onSuccess() {
      var params2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params2[_i] = arguments[_i];
      }
      setLoadingMore(false);
      if (options.onSuccess) {
        options.onSuccess.apply(options, __spread4(params2));
      }
    }
  }));
  var data = result.data, run = result.run, params = result.params, reset = result.reset, loading = result.loading, fetches = result.fetches;
  var reload = (0, import_react4.useCallback)(function() {
    reset();
    var _a2 = __read4(params), restParams = _a2.slice(1);
    run.apply(void 0, __spread4([void 0], restParams));
  }, [run, reset, params]);
  var reloadRef = (0, import_react4.useRef)(reload);
  reloadRef.current = reload;
  useUpdateEffect_default(function() {
    if (!options.manual) {
      reloadRef.current();
    }
  }, __spread4(refreshDeps));
  var dataGroup = (0, import_react4.useMemo)(function() {
    var listGroup = [];
    var lastNoLoadingData = data;
    Object.values(fetches).forEach(function(h) {
      var _a2, _b2;
      if ((_a2 = h.data) === null || _a2 === void 0 ? void 0 : _a2.list) {
        listGroup = listGroup.concat((_b2 = h.data) === null || _b2 === void 0 ? void 0 : _b2.list);
      }
      if (!h.loading) {
        lastNoLoadingData = h.data;
      }
    });
    return __assign2(__assign2({}, lastNoLoadingData), {
      list: listGroup
    });
  }, [fetches, data]);
  var noMore = isNoMore ? !loading && !loadingMore && isNoMore(dataGroup) : false;
  var loadMore = (0, import_react4.useCallback)(function() {
    if (noMore) {
      return;
    }
    setLoadingMore(true);
    var _a2 = __read4(params), restParams = _a2.slice(1);
    run.apply(void 0, __spread4([dataGroup], restParams));
  }, [noMore, run, dataGroup, params]);
  var scrollMethod = function scrollMethod2() {
    if (loading || loadingMore || !ref || !ref.current) {
      return;
    }
    if (ref.current.scrollHeight - ref.current.scrollTop <= ref.current.clientHeight + threshold) {
      loadMore();
    }
  };
  var scrollMethodRef = (0, import_react4.useRef)(scrollMethod);
  scrollMethodRef.current = scrollMethod;
  (0, import_react4.useEffect)(function() {
    if (!ref || !ref.current) {
      return function() {
      };
    }
    var scrollTrigger = function scrollTrigger2() {
      return scrollMethodRef.current();
    };
    ref.current.addEventListener("scroll", scrollTrigger);
    return function() {
      if (ref && ref.current) {
        ref.current.removeEventListener("scroll", scrollTrigger);
      }
    };
  }, [scrollMethodRef]);
  return __assign2(__assign2({}, result), {
    data: dataGroup,
    reload,
    loading: loading && dataGroup.list.length === 0,
    loadMore,
    loadingMore,
    noMore
  });
}
var useLoadMore_default = useLoadMore;

// node_modules/@ahooksjs/use-request/es/usePaginated.js
var import_react5 = __toModule(require_react());
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __read5 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spread5 = function() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read5(arguments[i]));
  }
  return ar;
};
function usePaginated(service, options) {
  var paginated = options.paginated, _a = options.defaultPageSize, defaultPageSize = _a === void 0 ? 10 : _a, _b = options.refreshDeps, refreshDeps = _b === void 0 ? [] : _b, fetchKey = options.fetchKey, restOptions = __rest2(options, ["paginated", "defaultPageSize", "refreshDeps", "fetchKey"]);
  (0, import_react5.useEffect)(function() {
    if (fetchKey) {
      console.error("useRequest pagination's fetchKey will not work!");
    }
  }, []);
  var _c = useAsync_default(service, __assign3({
    defaultParams: [{
      current: 1,
      pageSize: defaultPageSize
    }]
  }, restOptions)), data = _c.data, params = _c.params, run = _c.run, loading = _c.loading, rest = __rest2(_c, ["data", "params", "run", "loading"]);
  var _d = params && params[0] ? params[0] : {}, _e = _d.current, current = _e === void 0 ? 1 : _e, _f = _d.pageSize, pageSize = _f === void 0 ? defaultPageSize : _f, _g = _d.sorter, sorter = _g === void 0 ? {} : _g, _h = _d.filters, filters = _h === void 0 ? {} : _h;
  var runChangePagination = (0, import_react5.useCallback)(function(paginationParams) {
    var _a2 = __read5(params), oldPaginationParams = _a2[0], restParams = _a2.slice(1);
    run.apply(void 0, __spread5([__assign3(__assign3({}, oldPaginationParams), paginationParams)], restParams));
  }, [run, params]);
  var total = (data === null || data === void 0 ? void 0 : data.total) || 0;
  var totalPage = (0, import_react5.useMemo)(function() {
    return Math.ceil(total / pageSize);
  }, [pageSize, total]);
  var onChange = (0, import_react5.useCallback)(function(c, p) {
    var toCurrent = c <= 0 ? 1 : c;
    var toPageSize = p <= 0 ? 1 : p;
    var tempTotalPage = Math.ceil(total / toPageSize);
    if (toCurrent > tempTotalPage) {
      toCurrent = tempTotalPage;
    }
    runChangePagination({
      current: c,
      pageSize: p
    });
  }, [total, runChangePagination]);
  var changeCurrent = (0, import_react5.useCallback)(function(c) {
    onChange(c, pageSize);
  }, [onChange, pageSize]);
  var changePageSize = (0, import_react5.useCallback)(function(p) {
    onChange(current, p);
  }, [onChange, current]);
  var changeCurrentRef = (0, import_react5.useRef)(changeCurrent);
  changeCurrentRef.current = changeCurrent;
  useUpdateEffect_default(function() {
    if (!options.manual) {
      changeCurrentRef.current(1);
    }
  }, __spread5(refreshDeps));
  var changeTable = (0, import_react5.useCallback)(function(p, f, s) {
    runChangePagination({
      current: p.current,
      pageSize: p.pageSize || defaultPageSize,
      filters: f,
      sorter: s
    });
  }, [filters, sorter, runChangePagination]);
  return __assign3({
    loading,
    data,
    params,
    run,
    pagination: {
      current,
      pageSize,
      total,
      totalPage,
      onChange,
      changeCurrent,
      changePageSize
    },
    tableProps: {
      dataSource: (data === null || data === void 0 ? void 0 : data.list) || [],
      loading,
      onChange: changeTable,
      pagination: {
        current,
        pageSize,
        total
      }
    },
    sorter,
    filters
  }, rest);
}
var usePaginated_default = usePaginated;

// node_modules/@ahooksjs/use-request/es/configContext.js
var import_react6 = __toModule(require_react());
var ConfigContext = import_react6.default.createContext({});
ConfigContext.displayName = "UseRequestConfigContext";
var configContext_default = ConfigContext;

// node_modules/@ahooksjs/use-request/es/index.js
var __assign4 = function() {
  __assign4 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
var __rest3 = function(s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __read6 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spread6 = function() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read6(arguments[i]));
  }
  return ar;
};
function useRequest(service, options) {
  if (options === void 0) {
    options = {};
  }
  var contextConfig = (0, import_react7.useContext)(configContext_default);
  var finalOptions = __assign4(__assign4({}, contextConfig), options);
  var paginated = finalOptions.paginated, loadMore = finalOptions.loadMore, requestMethod = finalOptions.requestMethod;
  var paginatedRef = (0, import_react7.useRef)(paginated);
  var loadMoreRef = (0, import_react7.useRef)(loadMore);
  if (paginatedRef.current !== paginated) {
    throw Error("You should not modify the paginated of options");
  }
  if (loadMoreRef.current !== loadMore) {
    throw Error("You should not modify the loadMore of options");
  }
  paginatedRef.current = paginated;
  loadMoreRef.current = loadMore;
  var fetchProxy = function fetchProxy2() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return fetch.apply(void 0, __spread6(args)).then(function(res) {
      if (res.ok) {
        return res.json();
      }
      throw new Error(res.statusText);
    });
  };
  var finalRequestMethod = requestMethod || fetchProxy;
  var promiseService;
  switch (typeof service) {
    case "string":
      promiseService = function promiseService2() {
        return finalRequestMethod(service);
      };
      break;
    case "object":
      var url_1 = service.url, rest_1 = __rest3(service, ["url"]);
      promiseService = function promiseService2() {
        return requestMethod ? requestMethod(service) : fetchProxy(url_1, rest_1);
      };
      break;
    default:
      promiseService = function promiseService2() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return new Promise(function(resolve, reject) {
          var s = service.apply(void 0, __spread6(args));
          var fn = s;
          if (!s.then) {
            switch (typeof s) {
              case "string":
                fn = finalRequestMethod(s);
                break;
              case "object":
                var url_2 = s.url, rest_2 = __rest3(s, ["url"]);
                fn = requestMethod ? requestMethod(s) : fetchProxy(url_2, rest_2);
                break;
            }
          }
          fn.then(resolve)["catch"](reject);
        });
      };
  }
  if (loadMore) {
    return useLoadMore_default(promiseService, finalOptions);
  }
  if (paginated) {
    return usePaginated_default(promiseService, finalOptions);
  }
  return useAsync_default(promiseService, finalOptions);
}
var UseRequestProvider = configContext_default.Provider;
var UseAPIProvider = UseRequestProvider;
var es_default = useRequest;

// dep:@ahooksjs_use-request
var ahooksjs_use_request_default = es_default;
export {
  UseAPIProvider,
  UseRequestProvider,
  ahooksjs_use_request_default as default,
  useAsync_default as useAsync,
  useLoadMore_default as useLoadMore,
  usePaginated_default as usePaginated
};
//# sourceMappingURL=@ahooksjs_use-request.js.map
