import UnocssInspector from '@unocss/inspector';
import { createFilter } from '@rollup/pluginutils';
import { createConfigLoader } from '@unocss/config';
import { createGenerator, BetterMap } from '@unocss/core';
import { createHash } from 'crypto';

const defaultExclude = [/\.(css|postcss|sass|scss|less|stylus|styl)$/];
const defaultInclude = [/\.vue$/, /\.vue\?vue/, /\.svelte$/, /\.[jt]sx$/, /\.mdx?$/, /\.astro$/];

const VIRTUAL_ENTRY_ALIAS = [
  /^(?:virtual:)?uno(?::(.+))?\.css(\?.*)?$/
];
const LAYER_MARK_ALL = "__ALL__";
function resolveId(id) {
  for (const alias of VIRTUAL_ENTRY_ALIAS) {
    const match = id.match(alias);
    if (match) {
      return match[1] ? {
        id: `/__uno_${match[1]}.css`,
        layer: match[1]
      } : {
        id: "/__uno.css",
        layer: LAYER_MARK_ALL
      };
    }
  }
}
const LAYER_PLACEHOLDER_RE = /(\\?")?#--unocss--\s*{\s*layer\s*:\s*(.+?);?\s*}/g;
function getLayerPlaceholder(layer) {
  return `#--unocss--{layer:${layer}}`;
}
const HASH_PLACEHOLDER_RE = /#--unocss-hash--\s*{\s*content\s*:\s*"(.+?)";?\s*}/g;
function getHashPlaceholder(hash) {
  return `#--unocss-hash--{content:"${hash}"}`;
}

const INCLUDE_COMMENT = "@unocss-include";

function createContext(configOrPath, defaults = {}, extraConfigSources = []) {
  const loadConfig = createConfigLoader(configOrPath, extraConfigSources);
  let rawConfig = {};
  const uno = createGenerator(rawConfig, defaults);
  let rollupFilter = createFilter(defaultInclude, defaultExclude);
  const invalidations = [];
  const modules = new BetterMap();
  const tokens = new Set();
  const ready = reloadConfig();
  async function reloadConfig() {
    const result = await loadConfig();
    rawConfig = result.config;
    uno.setConfig(rawConfig);
    uno.config.envMode = "dev";
    rollupFilter = createFilter(rawConfig.include || defaultInclude, rawConfig.exclude || defaultExclude);
    tokens.clear();
    await Promise.all(modules.map((code, id) => uno.applyExtractors(code, id, tokens)));
    invalidate();
    return result;
  }
  function invalidate() {
    invalidations.forEach((cb) => cb());
  }
  async function extract(code, id) {
    if (id)
      modules.set(id, code);
    const len = tokens.size;
    await uno.applyExtractors(code, id, tokens);
    if (tokens.size > len)
      invalidate();
  }
  const filter = (code, id) => {
    return code.includes(INCLUDE_COMMENT) || rollupFilter(id);
  };
  async function getConfig() {
    await ready;
    return rawConfig;
  }
  return {
    ready,
    tokens,
    modules,
    invalidate,
    onInvalidate(fn) {
      invalidations.push(fn);
    },
    filter,
    reloadConfig,
    uno,
    extract,
    getConfig
  };
}

function getHash(input, length = 8) {
  return createHash("sha256").update(input).digest("hex").slice(0, length);
}
function getPath(id) {
  return id.replace(/\?.*$/, "");
}

function ChunkModeBuildPlugin({ uno, filter }) {
  let cssPlugin;
  const files = {};
  return {
    name: "unocss:chunk",
    apply: "build",
    enforce: "pre",
    configResolved(config) {
      cssPlugin = config.plugins.find((i) => i.name === "vite:css-post");
    },
    transform(code, id) {
      if (!filter(code, id))
        return;
      files[id] = code;
      return null;
    },
    async renderChunk(_, chunk) {
      const chunks = Object.keys(chunk.modules).map((i) => files[i]).filter(Boolean);
      if (!chunks.length)
        return null;
      const tokens = new Set();
      await Promise.all(chunks.map((c) => uno.applyExtractors(c, void 0, tokens)));
      const { css } = await uno.generate(tokens);
      const fakeCssId = `${chunk.fileName}.css`;
      await cssPlugin.transform(css, fakeCssId);
      chunk.modules[fakeCssId] = {
        code: null,
        originalLength: 0,
        removedExports: [],
        renderedExports: [],
        renderedLength: 0
      };
      return null;
    },
    async transformIndexHtml(code) {
      const { css } = await uno.generate(code);
      if (css)
        return `${code}<style>${css}</style>`;
    }
  };
}

function GlobalModeBuildPlugin({ uno, ready, extract, tokens, modules, filter }) {
  const vfsLayerMap = new Map();
  let tasks = [];
  let cssPlugin;
  return [
    {
      name: "unocss:global:build:scan",
      apply: "build",
      enforce: "pre",
      buildStart() {
        tasks = [];
        vfsLayerMap.clear();
      },
      transform(code, id) {
        if (filter(code, id))
          tasks.push(extract(code, id));
        return null;
      },
      transformIndexHtml: {
        enforce: "pre",
        transform(code, { filename }) {
          tasks.push(extract(code, filename));
        }
      },
      resolveId(id) {
        const entry = resolveId(id);
        if (entry) {
          vfsLayerMap.set(entry.id, entry.layer);
          return entry.id;
        }
      },
      load(id) {
        const layer = vfsLayerMap.get(getPath(id));
        if (layer)
          return getLayerPlaceholder(layer);
      },
      async configResolved(config) {
        cssPlugin = config.plugins.find((i) => i.name === "vite:css-post");
        await ready;
      },
      async renderChunk(_, chunk) {
        if (!cssPlugin)
          return null;
        const chunks = Object.keys(chunk.modules).filter((i) => modules.has(i));
        if (!chunks.length)
          return null;
        const tokens2 = new Set();
        await Promise.all(chunks.map((c) => uno.applyExtractors(modules.get(c) || "", c, tokens2)));
        const { css } = await uno.generate(tokens2, { minify: true });
        if (!css)
          return null;
        const hash = getHash(css);
        const fakeCssId = `${chunk.fileName}-unocss-hash.css`;
        await cssPlugin.transform(getHashPlaceholder(hash), fakeCssId);
        chunk.modules[fakeCssId] = {
          code: null,
          originalLength: 0,
          removedExports: [],
          renderedExports: [],
          renderedLength: 0
        };
        return null;
      }
    },
    {
      name: "unocss:global:build:generate",
      apply(options, { command }) {
        return command === "build" && !options.build?.ssr;
      },
      enforce: "post",
      async generateBundle(_, bundle) {
        const files = Object.keys(bundle);
        const cssFiles = files.filter((i) => i.endsWith(".css"));
        if (!cssFiles.length)
          return;
        await Promise.all(tasks);
        const result = await uno.generate(tokens, { minify: true });
        let replaced = false;
        for (const file of cssFiles) {
          const chunk = bundle[file];
          if (chunk.type === "asset" && typeof chunk.source === "string") {
            chunk.source = chunk.source.replace(HASH_PLACEHOLDER_RE, "").replace(LAYER_PLACEHOLDER_RE, (_2, __, layer) => {
              replaced = true;
              return layer === LAYER_MARK_ALL ? result.getLayers(void 0, Array.from(vfsLayerMap.values())) : result.getLayer(layer) || "";
            });
          }
        }
        if (!replaced)
          this.error(new Error("[unocss] does not found CSS placeholder in the generated chunks,\nthis is likely an internal bug of unocss vite plugin"));
      }
    }
  ];
}

const READY_CALLBACK_DEFAULT = "/__unocss_ready";

const WARN_TIMEOUT = 2e3;
function GlobalModeDevPlugin({ uno, tokens, onInvalidate, extract, filter }) {
  const servers = [];
  const tasks = [];
  const entries = new Map();
  let invalidateTimer;
  let lastUpdate = Date.now();
  let lastServed = 0;
  let resolved = false;
  let resolvedWarnTimer;
  function invalidate(timer = 10) {
    for (const server of servers) {
      for (const id of entries.keys()) {
        const mod = server.moduleGraph.getModuleById(id);
        if (!mod)
          continue;
        server.moduleGraph.invalidateModule(mod);
      }
    }
    clearTimeout(invalidateTimer);
    invalidateTimer = setTimeout(sendUpdate, timer);
  }
  function sendUpdate() {
    lastUpdate = Date.now();
    for (const server of servers) {
      server.ws.send({
        type: "update",
        updates: Array.from(entries.keys()).map((i) => ({
          acceptedPath: i,
          path: i,
          timestamp: lastUpdate,
          type: "js-update"
        }))
      });
    }
  }
  function setWarnTimer() {
    if (!resolved && !resolvedWarnTimer) {
      resolvedWarnTimer = setTimeout(() => {
        if (!resolved) {
          const msg = "[unocss] entry module not found, have you add `import 'uno.css'` in your main entry?";
          console.warn(msg);
          servers.forEach(({ ws }) => ws.send({
            type: "error",
            err: { message: msg, stack: "" }
          }));
        }
      }, WARN_TIMEOUT);
    }
  }
  onInvalidate(invalidate);
  return [
    {
      name: "unocss:global",
      apply: "serve",
      enforce: "pre",
      async configureServer(_server) {
        servers.push(_server);
        _server.middlewares.use(async (req, res, next) => {
          setWarnTimer();
          if (req.url?.startsWith(READY_CALLBACK_DEFAULT)) {
            const servedTime = +req.url.slice(READY_CALLBACK_DEFAULT.length + 1);
            if (servedTime < lastUpdate)
              invalidate(0);
            res.statusCode = 200;
            res.end();
          } else {
            return next();
          }
        });
      },
      transform(code, id) {
        if (filter(code, id))
          extract(code, id);
        return null;
      },
      transformIndexHtml: {
        enforce: "pre",
        transform(code, { filename }) {
          extract(code, filename);
        }
      },
      resolveId(id) {
        const entry = resolveId(id);
        if (entry) {
          resolved = true;
          entries.set(entry.id, entry.layer);
          return entry.id;
        }
      },
      async load(id) {
        const layer = entries.get(getPath(id));
        if (!layer)
          return null;
        await Promise.all(tasks);
        const result = await uno.generate(tokens);
        lastServed = Date.now();
        return layer === LAYER_MARK_ALL ? result.getLayers(void 0, Array.from(entries.values())) : result.getLayer(layer);
      }
    },
    {
      name: "unocss:global:post",
      apply(config, env) {
        return env.command === "serve" && !config.build?.ssr;
      },
      enforce: "post",
      transform(code, id) {
        if (entries.has(getPath(id)) && code.includes("import.meta.hot"))
          return `${code}
await fetch("${READY_CALLBACK_DEFAULT}/${lastServed}")`;
      }
    }
  ];
}

function GlobalModePlugin(ctx) {
  return [
    ...GlobalModeBuildPlugin(ctx),
    ...GlobalModeDevPlugin(ctx)
  ];
}

const VIRTUAL_PREFIX = "/@unocss/";
const SCOPE_IMPORT_RE = / from (['"])(@unocss\/scope)\1/;
function PerModuleModePlugin({ uno, filter }) {
  const moduleMap = new Map();
  let server;
  const invalidate = (hash) => {
    if (!server)
      return;
    const id = `${VIRTUAL_PREFIX}${hash}.css`;
    const mod = server.moduleGraph.getModuleById(id);
    if (!mod)
      return;
    server.moduleGraph.invalidateModule(mod);
    server.ws.send({
      type: "update",
      updates: [{
        acceptedPath: id,
        path: id,
        timestamp: +Date.now(),
        type: "js-update"
      }]
    });
  };
  return {
    name: "unocss:module-scope",
    enforce: "post",
    configureServer(_server) {
      server = _server;
    },
    async transform(code, id) {
      if (!filter(code, id))
        return;
      const hash = getHash(id);
      const hasScope = code.match(SCOPE_IMPORT_RE);
      const { css } = await uno.generate(code, { id, scope: hasScope ? `.${hash}` : void 0, preflights: false });
      if (!css && !hasScope)
        return null;
      if (hasScope)
        code = code.replace(SCOPE_IMPORT_RE, ` from 'data:text/javascript;base64,${Buffer.from(`export default () => "${hash}"`).toString("base64")}'`);
      moduleMap.set(hash, [id, css]);
      invalidate(hash);
      return {
        code: `import "${VIRTUAL_PREFIX}${hash}.css";${code}`,
        map: null
      };
    },
    resolveId(id) {
      return id.startsWith(VIRTUAL_PREFIX) ? id : null;
    },
    load(id) {
      if (!id.startsWith(VIRTUAL_PREFIX))
        return null;
      const hash = id.slice(VIRTUAL_PREFIX.length, -".css".length);
      const [source, css] = moduleMap.get(hash) || [];
      if (source)
        this.addWatchFile(source);
      return `
/* unocss ${source} */
${css}`;
    }
  };
}

function VueScopedPlugin({ uno, ready }) {
  let filter = createFilter([/\.vue$/], defaultExclude);
  async function transformSFC(code) {
    const { css } = await uno.generate(code);
    if (!css)
      return null;
    return `${code}
<style scoped>${css}</style>`;
  }
  return {
    name: "unocss:vue-scoped",
    enforce: "pre",
    async configResolved() {
      const { config } = await ready;
      filter = createFilter(config.include || [/\.vue$/], config.exclude || defaultExclude);
    },
    transform(code, id) {
      if (!filter(id))
        return;
      return transformSFC(code);
    },
    handleHotUpdate(ctx) {
      const read = ctx.read;
      if (filter(ctx.file)) {
        ctx.read = async () => {
          const code = await read();
          return await transformSFC(code) || code;
        };
      }
    }
  };
}

function ConfigHMRPlugin(ctx) {
  const { ready, uno } = ctx;
  return {
    name: "unocss:config",
    async configResolved() {
      await ready;
    },
    async configureServer(server) {
      uno.config.envMode = "dev";
      const { sources } = await ready;
      if (!sources.length)
        return;
      server.watcher.add(sources);
      server.watcher.on("change", async (p) => {
        if (!sources.includes(p))
          return;
        await ctx.reloadConfig();
        server.ws.send({
          type: "custom",
          event: "unocss:config-changed"
        });
      });
    }
  };
}

function defineConfig(config) {
  return config;
}
function UnocssPlugin(configOrPath, defaults = {}) {
  const ctx = createContext(configOrPath, defaults);
  const inlineConfig = configOrPath && typeof configOrPath !== "string" ? configOrPath : {};
  const mode = inlineConfig.mode ?? "global";
  const plugins = [
    ConfigHMRPlugin(ctx)
  ];
  if (inlineConfig.inspector !== false)
    plugins.push(UnocssInspector(ctx));
  if (mode === "per-module") {
    plugins.push(PerModuleModePlugin(ctx));
  } else if (mode === "vue-scoped") {
    plugins.push(VueScopedPlugin(ctx));
  } else if (mode === "global") {
    plugins.push(...GlobalModePlugin(ctx));
  } else if (mode === "dist-chunk") {
    plugins.push(ChunkModeBuildPlugin(ctx), ...GlobalModeDevPlugin(ctx));
  } else {
    throw new Error(`[unocss] unknown mode "${mode}"`);
  }
  return plugins.filter(Boolean);
}

export { ChunkModeBuildPlugin, GlobalModeBuildPlugin, GlobalModeDevPlugin, GlobalModePlugin, PerModuleModePlugin, VueScopedPlugin, UnocssPlugin as default, defineConfig };
