// src/utils/escape.ts
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function escapeSelector(str) {
  const length = str.length;
  let index = -1;
  let codeUnit;
  let result = "";
  const firstCodeUnit = str.charCodeAt(0);
  while (++index < length) {
    codeUnit = str.charCodeAt(index);
    if (codeUnit === 0) {
      result += "\uFFFD";
      continue;
    }
    if (codeUnit === 44) {
      result += "\\2c ";
      continue;
    }
    if (codeUnit >= 1 && codeUnit <= 31 || codeUnit === 127 || index === 0 && codeUnit >= 48 && codeUnit <= 57 || index === 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit === 45) {
      result += `\\${codeUnit.toString(16)} `;
      continue;
    }
    if (index === 0 && length === 1 && codeUnit === 45) {
      result += `\\${str.charAt(index)}`;
      continue;
    }
    if (codeUnit >= 128 || codeUnit === 45 || codeUnit === 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
      result += str.charAt(index);
      continue;
    }
    result += `\\${str.charAt(index)}`;
  }
  return result;
}
var e = escapeSelector;

// src/utils/object.ts
function entriesToCss(arr) {
  if (arr == null)
    return "";
  return arr.map(([key, value]) => value != null ? `${key}:${value};` : void 0).filter(Boolean).join("");
}
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function mergeDeep(original, patch) {
  const o = original;
  const p = patch;
  if (Array.isArray(o) && Array.isArray(p))
    return [...o, ...p];
  if (Array.isArray(o))
    return [...o];
  const output = { ...o };
  if (isObject(o) && isObject(p)) {
    Object.keys(p).forEach((key) => {
      if (isObject(p[key])) {
        if (!(key in o))
          Object.assign(output, { [key]: p[key] });
        else
          output[key] = mergeDeep(o[key], p[key]);
      } else {
        Object.assign(output, { [key]: p[key] });
      }
    });
  }
  return output;
}
function isStaticRule(rule) {
  return typeof rule[0] === "string";
}
function isStaticShortcut(sc) {
  return typeof sc[0] === "string";
}

// src/utils/basic.ts
function toArray(value = []) {
  return Array.isArray(value) ? value : [value];
}
function uniq(value) {
  return Array.from(new Set(value));
}
function mergeSet(target, append) {
  append.forEach((i) => target.add(i));
  return target;
}

// src/utils/colors.ts
var hexRE = /^#?([\da-f]+)$/i;
function hex2rgba(hex = "") {
  const [, body] = hex.match(hexRE) || [];
  if (!body)
    return;
  switch (body.length) {
    case 3:
    case 4:
      const digits = Array.from(body, (s) => Number.parseInt(s, 16)).map((n) => n << 4 | n);
      if (body.length === 3)
        return digits;
      digits[3] = Math.round(digits[3] / 255 * 100) / 100;
      return digits;
    case 6:
    case 8:
      const value = Number.parseInt(body, 16);
      if (body.length === 6)
        return [value >> 16 & 255, value >> 8 & 255, value & 255];
      return [value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, Math.round((value & 255) / 255 * 100) / 100];
  }
}

// src/utils/helpers.ts
var attributifyRE = /^\[(.+?)~?="(.*)"\]$/;
var validateFilterRE = /[a-z?]/;
function isAttributifySelector(selector) {
  return selector.match(attributifyRE);
}
function isValidSelector(selector = "") {
  return validateFilterRE.test(selector);
}
function normalizeVariant(variant) {
  return typeof variant === "function" ? { match: variant } : variant;
}
function isRawUtil(util) {
  return util.length === 3;
}

// src/utils/map.ts
var TwoKeyMap = class {
  constructor() {
    this._map = new Map();
  }
  get(key1, key2) {
    const m2 = this._map.get(key1);
    if (m2)
      return m2.get(key2);
  }
  getFallback(key1, key2, fallback) {
    let m2 = this._map.get(key1);
    if (!m2) {
      m2 = new Map();
      this._map.set(key1, m2);
    }
    if (!m2.has(key2))
      m2.set(key2, fallback);
    return m2.get(key2);
  }
  set(key1, key2, value) {
    let m2 = this._map.get(key1);
    if (!m2) {
      m2 = new Map();
      this._map.set(key1, m2);
    }
    m2.set(key2, value);
    return this;
  }
  has(key1, key2) {
    var _a;
    return (_a = this._map.get(key1)) == null ? void 0 : _a.has(key2);
  }
  delete(key1, key2) {
    var _a;
    return ((_a = this._map.get(key1)) == null ? void 0 : _a.delete(key2)) || false;
  }
  deleteTop(key1) {
    return this._map.delete(key1);
  }
  map(fn) {
    return Array.from(this._map.entries()).flatMap(([k1, m2]) => Array.from(m2.entries()).map(([k2, v]) => {
      return fn(v, k1, k2);
    }));
  }
};
var BetterMap = class extends Map {
  map(mapFn) {
    const result = [];
    this.forEach((v, k) => {
      result.push(mapFn(v, k));
    });
    return result;
  }
};

// src/utils/layer.ts
function withLayer(layer, rules) {
  rules.forEach((r) => {
    if (!r[2])
      r[2] = { layer };
    else
      r[2].layer = layer;
  });
  return rules;
}

// src/extractors/split.ts
var extractorSplit = (code) => new Set(code.split(/[\s'"`;>=]+/g).filter(isValidSelector));

// src/config.ts
function resolveShortcuts(shortcuts) {
  return toArray(shortcuts).flatMap((s) => {
    if (Array.isArray(s))
      return [s];
    return Object.entries(s);
  });
}
function resolveConfig(userConfig = {}, defaults = {}) {
  const config = Object.assign({}, defaults, userConfig);
  const rawPresets = config.presets || [];
  const sortedPresets = [
    ...rawPresets.filter((p) => p.enforce === "pre"),
    ...rawPresets.filter((p) => !p.enforce),
    ...rawPresets.filter((p) => p.enforce === "post")
  ];
  const layers = Object.assign({}, ...rawPresets.map((i) => i.layers), userConfig.layers);
  function mergePresets(key) {
    return uniq([
      ...sortedPresets.flatMap((p) => toArray(p[key] || [])),
      ...toArray(config[key] || [])
    ]);
  }
  const extractors = mergePresets("extractors");
  if (!extractors.length)
    extractors.push(extractorSplit);
  const rules = mergePresets("rules");
  const rulesStaticMap = {};
  const rulesSize = rules.length;
  rules.forEach((rule, i) => {
    if (isStaticRule(rule)) {
      rulesStaticMap[rule[0]] = [i, rule[1], rule[2]];
      delete rules[i];
    }
  });
  const theme = [
    ...sortedPresets.map((p) => p.theme || {}),
    config.theme || {}
  ].reduce((a, p) => mergeDeep(a, p), {});
  return {
    mergeSelectors: true,
    warnExcluded: true,
    excluded: [],
    sortLayers: (layers2) => layers2,
    ...config,
    layers,
    theme,
    rulesSize,
    rulesDynamic: rules,
    rulesStaticMap,
    preflights: mergePresets("preflights"),
    variants: mergePresets("variants").map(normalizeVariant),
    shortcuts: resolveShortcuts(mergePresets("shortcuts")),
    extractors
  };
}

// src/generator/index.ts
var UnoGenerator = class {
  constructor(userConfig = {}, defaults = {}) {
    this.userConfig = userConfig;
    this.defaults = defaults;
    this._cache = new Map();
    this.excluded = new Set();
    this.config = resolveConfig(userConfig, defaults);
  }
  setConfig(userConfig, defaults) {
    if (!userConfig)
      return;
    if (defaults)
      this.defaults = defaults;
    this.userConfig = userConfig;
    this.config = resolveConfig(userConfig, this.defaults);
    this.excluded = new Set();
    this._cache = new Map();
  }
  async applyExtractors(code, id, set = new Set()) {
    await Promise.all(this.config.extractors.map(async (i) => {
      const result = await i(code, id);
      result == null ? void 0 : result.forEach((t) => set.add(t));
    }));
    return set;
  }
  async generate(input, {
    id,
    scope,
    preflights = true,
    layerComments = true
  } = {}) {
    const tokens = typeof input === "string" ? await this.applyExtractors(input, id) : input;
    const layerSet = new Set(["default"]);
    const matched = new Set();
    const sheet = new Map();
    const hit = (raw, payload) => {
      var _a;
      this._cache.set(raw, payload);
      matched.add(raw);
      for (const item of payload) {
        const query = item[3] || "";
        if (!sheet.has(query))
          sheet.set(query, []);
        sheet.get(query).push(item);
        if ((_a = item[4]) == null ? void 0 : _a.layer)
          layerSet.add(item[4].layer);
      }
    };
    await Promise.all(Array.from(tokens).map(async (raw) => {
      if (matched.has(raw) || this.excluded.has(raw))
        return;
      if (this._cache.has(raw)) {
        const r = this._cache.get(raw);
        if (r)
          hit(raw, r);
        return;
      }
      if (this.isExcluded(raw)) {
        this.excluded.add(raw);
        this._cache.set(raw, null);
        return;
      }
      const applied = this.matchVariants(raw);
      if (this.isExcluded(applied[1])) {
        this.excluded.add(raw);
        this._cache.set(raw, null);
        return;
      }
      const expanded = this.expandShortcut(applied[1]);
      if (expanded) {
        const utils = await this.stringifyShortcuts(applied, expanded[0], expanded[1]);
        if (utils == null ? void 0 : utils.length) {
          hit(raw, utils);
          return;
        }
      } else {
        const util = this.stringifyUtil(await this.parseUtil(applied));
        if (util) {
          hit(raw, [util]);
          return;
        }
      }
      this._cache.set(raw, null);
    }));
    if (preflights) {
      this.config.preflights.forEach((i) => {
        if (i.layer)
          layerSet.add(i.layer);
      });
    }
    const layerCache = {};
    const layers = this.config.sortLayers(Array.from(layerSet).sort((a, b) => {
      var _a, _b;
      return ((_a = this.config.layers[a]) != null ? _a : 0) - ((_b = this.config.layers[b]) != null ? _b : 0) || a.localeCompare(b);
    }));
    const getLayer = (layer) => {
      if (layerCache[layer])
        return layerCache[layer];
      let css = Array.from(sheet).map(([query, items]) => {
        const size = items.length;
        const sorted = items.filter((i) => {
          var _a;
          return (((_a = i[4]) == null ? void 0 : _a.layer) || "default") === layer;
        }).sort((a, b) => {
          var _a;
          return a[0] - b[0] || ((_a = a[1]) == null ? void 0 : _a.localeCompare(b[1] || "")) || 0;
        }).map((a) => [a[1] ? applyScope(a[1], scope) : a[1], a[2]]);
        if (!sorted.length)
          return void 0;
        const rules = sorted.map(([selector, body], idx) => {
          if (selector && this.config.mergeSelectors) {
            for (let i = size - 1; i > idx; i--) {
              const current = sorted[i];
              if (current && current[0] && current[1] === body) {
                current[0] = `${selector},${current[0]}`;
                return null;
              }
            }
          }
          return selector ? `${selector}{${body}}` : body;
        }).filter(Boolean).join("\n");
        return query ? `${query}{
${rules}
}` : rules;
      }).filter(Boolean).join("\n");
      if (preflights) {
        css = [
          ...this.config.preflights.filter((i) => (i.layer || "default") === layer).map((i) => i.getCSS()).filter(Boolean),
          css
        ].join("\n");
      }
      return layerCache[layer] = layerComments ? `/* layer: ${layer} */
${css}` : css;
    };
    const getLayers = (excludes) => {
      return layers.filter((i) => !(excludes == null ? void 0 : excludes.includes(i))).map((i) => getLayer(i) || "").join("\n");
    };
    return {
      get css() {
        return getLayers();
      },
      layers,
      getLayers,
      getLayer,
      matched
    };
  }
  matchVariants(raw) {
    const usedVariants = new Set();
    const handlers = [];
    let processed = raw;
    let applied = false;
    while (true) {
      applied = false;
      for (const v of this.config.variants) {
        if (!v.multiPass && usedVariants.has(v))
          continue;
        let handler = v.match(processed, raw, this.config.theme);
        if (!handler)
          continue;
        if (typeof handler === "string")
          handler = { matcher: handler };
        if (handler) {
          processed = handler.matcher;
          handlers.push(handler);
          usedVariants.add(v);
          applied = true;
          break;
        }
      }
      if (!applied)
        break;
      if (handlers.length > 500)
        throw new Error(`Too many variants applied to "${raw}"`);
    }
    return [raw, processed, handlers];
  }
  applyVariants(parsed, variantHandlers = parsed[4], raw = parsed[1]) {
    const selector = variantHandlers.reduce((p, v) => {
      var _a;
      return ((_a = v.selector) == null ? void 0 : _a.call(v, p)) || p;
    }, toEscapedSelector(raw));
    const mediaQuery = variantHandlers.reduce((p, v) => v.mediaQuery || p, void 0);
    const entries = variantHandlers.reduce((p, v) => {
      var _a;
      return ((_a = v.body) == null ? void 0 : _a.call(v, p)) || p;
    }, parsed[2]);
    return [
      selector,
      entries,
      mediaQuery
    ];
  }
  constructCustomCSS(context, body, overrideSelector) {
    body = normalizeEntries(body);
    const [selector, entries, mediaQuery] = this.applyVariants([0, overrideSelector || context.rawSelector, body, void 0, context.variantHandlers]);
    const cssBody = `${selector}{${entriesToCss(entries)}}`;
    if (mediaQuery)
      return `${mediaQuery}{${cssBody}}`;
    return cssBody;
  }
  async parseUtil(input) {
    const { theme, rulesStaticMap, rulesDynamic, rulesSize } = this.config;
    const [raw, processed, variantHandlers] = typeof input === "string" ? this.matchVariants(input) : input;
    const staticMatch = rulesStaticMap[processed];
    if (staticMatch == null ? void 0 : staticMatch[1])
      return [staticMatch[0], raw, normalizeEntries(staticMatch[1]), staticMatch[2], variantHandlers];
    const context = {
      rawSelector: raw,
      currentSelector: processed,
      theme,
      generator: this,
      variantHandlers,
      constructCSS: (...args) => this.constructCustomCSS(context, ...args)
    };
    for (let i = rulesSize; i >= 0; i--) {
      const rule = rulesDynamic[i];
      if (!rule)
        continue;
      const [matcher, handler, meta] = rule;
      const match = processed.match(matcher);
      if (!match)
        continue;
      const result = await handler(match, context);
      if (typeof result === "string")
        return [i, result, meta];
      if (result)
        return [i, raw, normalizeEntries(result), meta, variantHandlers];
    }
  }
  stringifyUtil(parsed) {
    if (!parsed)
      return;
    if (isRawUtil(parsed))
      return [parsed[0], void 0, parsed[1], void 0, parsed[2]];
    const [selector, entries, mediaQuery] = this.applyVariants(parsed);
    const body = entriesToCss(entries);
    if (!body)
      return;
    return [parsed[0], selector, body, mediaQuery, parsed[3]];
  }
  expandShortcut(processed, depth = 3) {
    if (depth === 0)
      return;
    let meta;
    let result;
    for (const s of this.config.shortcuts) {
      if (isStaticShortcut(s)) {
        if (s[0] === processed) {
          meta = meta || s[2];
          result = s[1];
          break;
        }
      } else {
        const match = processed.match(s[0]);
        if (match)
          result = s[1](match);
        if (result) {
          meta = meta || s[2];
          break;
        }
      }
    }
    if (!result)
      return;
    if (typeof result === "string")
      result = result.split(/ /g);
    return [
      result.flatMap((r) => {
        var _a;
        return ((_a = this.expandShortcut(r, depth - 1)) == null ? void 0 : _a[0]) || [r];
      }),
      meta
    ];
  }
  async stringifyShortcuts(parent, expanded, meta) {
    const selectorMap = new TwoKeyMap();
    const parsed = (await Promise.all(uniq(expanded).map((i) => this.parseUtil(i)))).filter(Boolean).sort((a, b) => a[0] - b[0]);
    const [raw, , parentVariants] = parent;
    for (const item of parsed) {
      if (isRawUtil(item))
        continue;
      const [selector, entries, mediaQuery] = this.applyVariants(item, [...item[4], ...parentVariants], raw);
      const mapItem = selectorMap.getFallback(selector, mediaQuery, [[], item[0]]);
      mapItem[0].push(...entries);
      if (item[0] > mapItem[1])
        mapItem[1] = item[0];
    }
    return selectorMap.map(([entries, index], selector, mediaQuery) => {
      const body = entriesToCss(entries);
      if (body)
        return [index, selector, body, mediaQuery, meta];
      return void 0;
    }).filter(Boolean);
  }
  isExcluded(raw) {
    return this.config.excluded.some((e2) => typeof e2 === "string" ? e2 === raw : e2.test(raw));
  }
};
function createGenerator(config, defaults) {
  return new UnoGenerator(config, defaults);
}
var reScopePlaceholder = / \$\$ /;
var hasScopePlaceholder = (css) => css.match(reScopePlaceholder);
function applyScope(css, scope) {
  if (hasScopePlaceholder(css))
    return css.replace(reScopePlaceholder, scope ? ` ${scope} ` : " ");
  else
    return scope ? `${scope} ${css}` : css;
}
function toEscapedSelector(raw) {
  if (raw.startsWith("["))
    return raw.replace(/^\[(.+?)(~?=)"(.*)"\]$/, (_, n, s, i) => `[${e(n)}${s}"${e(i)}"]`);
  else
    return `.${e(raw)}`;
}
function normalizeEntries(obj) {
  return !Array.isArray(obj) ? Object.entries(obj) : obj;
}
export {
  BetterMap,
  TwoKeyMap,
  UnoGenerator,
  attributifyRE,
  createGenerator,
  e,
  entriesToCss,
  escapeRegExp,
  escapeSelector,
  extractorSplit,
  hasScopePlaceholder,
  hex2rgba,
  isAttributifySelector,
  isObject,
  isRawUtil,
  isStaticRule,
  isStaticShortcut,
  isValidSelector,
  mergeDeep,
  mergeSet,
  normalizeVariant,
  toArray,
  uniq,
  validateFilterRE,
  withLayer
};
