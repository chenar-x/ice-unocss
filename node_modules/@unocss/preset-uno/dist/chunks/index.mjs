const directionMap = {
  "l": ["-left"],
  "r": ["-right"],
  "t": ["-top"],
  "b": ["-bottom"],
  "s": ["-inline-start"],
  "e": ["-inline-end"],
  "x": ["-left", "-right"],
  "y": ["-top", "-bottom"],
  "": [""],
  "a": [""]
};
const cornerMap = {
  "t": ["-top-left", "-top-right"],
  "r": ["-top-right", "-bottom-right"],
  "b": ["-bottom-left", "-bottom-right"],
  "l": ["-bottom-left", "-top-left"],
  "tl": ["-top-left"],
  "lt": ["-top-left"],
  "tr": ["-top-right"],
  "rt": ["-top-right"],
  "bl": ["-bottom-left"],
  "lb": ["-bottom-left"],
  "br": ["-bottom-right"],
  "rb": ["-bottom-right"],
  "": [""]
};
const xyzMap = {
  "x": ["-x"],
  "y": ["-y"],
  "z": ["-z"],
  "": ["-x", "-y"]
};

const numberWithUnitRE = /^(-?[0-9.]+)(px|pt|pc|rem|em|%|vh|vw|in|cm|mm|ex|ch|vmin|vmax)?$/i;
const numberRE = /^(-?[0-9.]+)$/i;
function rem(str) {
  if (str === "auto" || str === "a")
    return "auto";
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n, unit] = match;
  if (unit)
    return str;
  const num = parseFloat(n);
  if (!Number.isNaN(num))
    return `${num / 4}rem`;
}
function px(str) {
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n, unit] = match;
  if (unit)
    return str;
  const num = parseFloat(n);
  if (!Number.isNaN(num))
    return `${num}px`;
}
function number(str) {
  if (!numberRE.test(str))
    return;
  const num = parseFloat(str);
  if (!Number.isNaN(num))
    return num;
}
function percent(str) {
  if (str.endsWith("%"))
    str = str.slice(0, -1);
  const num = parseFloat(str);
  if (!Number.isNaN(num))
    return `${num / 100}`;
}
function fraction(str) {
  if (str === "full")
    return "100%";
  const [left, right] = str.split("/");
  const num = parseFloat(left) / parseFloat(right);
  if (!Number.isNaN(num))
    return `${num * 100}%`;
}
function bracket(str) {
  if (str && str[0] === "[" && str[str.length - 1] === "]") {
    return str.slice(1, -1).replace(/_/g, " ").replace(/calc\((.*)/g, (v) => {
      return v.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ");
    });
  }
}
function cssvar(str) {
  if (str.startsWith("$"))
    return `var(--${str.slice(1)})`;
}
function time(str) {
  const duration = Number(str.replace(/(s|ms)$/, ""));
  if (isNaN(duration))
    return;
  if (/ms|s$/.test(str))
    return str;
  return `${str}ms`;
}
function global(str) {
  if (["inherit", "initial", "unset"].includes(str))
    return str;
}

const handlers = {
  __proto__: null,
  rem: rem,
  px: px,
  number: number,
  percent: percent,
  fraction: fraction,
  bracket: bracket,
  cssvar: cssvar,
  time: time,
  global: global
};

const handlersNames = Object.keys(handlers);
const handler = function(str) {
  const s = this.__options?.sequence || [];
  this.__options.sequence = [];
  for (const n of s) {
    const res = handlers[n](str);
    if (res != null)
      return res;
  }
  return void 0;
};
function addProcessor(that, name) {
  if (!that.__options) {
    that.__options = {
      sequence: []
    };
  }
  that.__options.sequence.push(name);
  return that;
}
handlersNames.forEach((i) => {
  Object.defineProperty(handler, i, {
    enumerable: true,
    get() {
      return addProcessor(this, i);
    }
  });
});

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

export { capitalize as a, percent as b, cornerMap as c, directionMap as d, bracket as e, fraction as f, cssvar as g, handler as h, global as i, handlersNames as j, number as n, px as p, rem as r, time as t, xyzMap as x };
