import { writeFile, readFile } from 'fs/promises';
import { resolve, relative, basename } from 'pathe';
import fg from 'fast-glob';
import consola from 'consola';
import { cyan, green, white, dim } from 'colorette';
import { createGenerator } from '@unocss/core';
import { createConfigLoader } from '@unocss/config';
import presetUno from '@unocss/preset-uno';

const version = "0.14.3";

class PrettyError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function")
      Error.captureStackTrace(this, this.constructor);
    else
      this.stack = new Error(message).stack;
  }
}
function handleError(error) {
  if (error instanceof PrettyError)
    consola.error(error.message);
  process.exitCode = 1;
}

function debouncePromise(fn, delay, onError) {
  let timeout;
  let promiseInFly;
  let callbackPending;
  return function debounced(...args) {
    if (promiseInFly) {
      callbackPending = () => {
        debounced(...args);
        callbackPending = void 0;
      };
    } else {
      if (timeout)
        clearTimeout(timeout);
      timeout = setTimeout(() => {
        timeout = void 0;
        promiseInFly = fn(...args).catch(onError).finally(() => {
          promiseInFly = void 0;
          if (callbackPending)
            callbackPending();
        });
      }, delay);
    }
  };
}

const defaultConfig = {
  envMode: "build",
  presets: [
    presetUno()
  ]
};

const name = "unocss";
let uno;
const fileCache = new Map();
async function generate(options) {
  const outFile = options.outFile ?? resolve(process.cwd(), "uno.css");
  const { css, matched } = await uno.generate([...fileCache].join("\n"));
  await writeFile(outFile, css, "utf-8");
  if (!options.watch) {
    consola.success(`${[...matched].length} utilities generated to ${cyan(relative(process.cwd(), outFile))}
`);
  }
}
async function resolveOptions(options) {
  if (!options.patterns?.length) {
    throw new PrettyError(`No glob patterns, try ${cyan(`${name} <path/to/**/*>`)}`);
  }
  return options;
}
async function build(_options) {
  const options = await resolveOptions(_options);
  const loadConfig = createConfigLoader();
  const { config, sources: configSources } = await loadConfig();
  uno = createGenerator(config, defaultConfig);
  const files = await fg(options.patterns);
  await Promise.all(files.map(async (file) => {
    fileCache.set(file, await readFile(file, "utf8"));
  }));
  consola.log(green(`${name} v${version}`));
  consola.start(`UnoCSS ${options.watch ? "in watch mode..." : "for production..."}`);
  const debouncedBuild = debouncePromise(async () => {
    generate(options);
  }, 100, handleError);
  const startWatcher = async () => {
    if (!options.watch)
      return;
    const { watch } = await import('chokidar');
    const { patterns } = options;
    const ignored = ["**/{.git,node_modules}/**"];
    consola.info(`Watching for changes in ${cyan(Array.isArray(patterns) ? patterns.join(white(", ")) : patterns)}`);
    const watcher = watch(patterns, {
      ignoreInitial: true,
      ignorePermissionErrors: true,
      ignored
    });
    if (configSources.length) {
      watcher.add(configSources);
      watcher.on("all", async (type, file) => {
        if (configSources.includes(file)) {
          uno.setConfig((await loadConfig()).config);
          consola.info(`${cyan(basename(file))} changed, setting new config`);
        } else {
          consola.log(`${green(`${type}`)} ${white(dim(file))}`);
          if (type.startsWith("unlink"))
            fileCache.delete(file);
          else
            fileCache.set(file, await readFile(file, "utf8"));
        }
        debouncedBuild();
      });
    }
  };
  await generate(options);
  startWatcher();
}

export { build as b, generate as g, handleError as h, resolveOptions as r, version as v };
