var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import React from 'react';
/**
 * ModelApis Plugin
 *
 * generates hooks for store
 */
export default (function () {
    return {
        onStoreCreated: function (store) {
            // hooks
            function useModel(name) {
                var state = useModelState(name);
                var dispatchers = useModelDispatchers(name);
                return [state, dispatchers];
            }
            function useModelState(name) {
                var selector = store.useSelector(function (state) { return state[name]; });
                if (typeof selector !== "undefined") {
                    return selector;
                }
                throw new Error("Not found model by namespace: " + name + ".");
            }
            function useModelDispatchers(name) {
                var dispatch = store.useDispatch();
                if (dispatch[name]) {
                    return dispatch[name];
                }
                throw new Error("Not found model by namespace: " + name + ".");
            }
            function useModelEffectsState(name) {
                var dispatch = useModelDispatchers(name);
                var effectsLoading = useModelEffectsLoading(name);
                var effectsError = useModelEffectsError(name);
                var states = {};
                Object.keys(dispatch).forEach(function (key) {
                    states[key] = {
                        isLoading: effectsLoading[key],
                        error: effectsError[key] ? effectsError[key].error : null,
                    };
                });
                return states;
            }
            function useModelEffectsError(name) {
                return store.useSelector(function (state) { return state.error ? state.error.effects[name] : undefined; });
            }
            function useModelEffectsLoading(name) {
                return store.useSelector(function (state) { return state.loading ? state.loading.effects[name] : undefined; });
            }
            // other apis
            function getModel(name) {
                return [getModelState(name), getModelDispatchers(name)];
            }
            function getModelState(name) {
                return store.getState()[name];
            }
            function getModelDispatchers(name) {
                return store.dispatch[name];
            }
            // class component support
            function withModel(name, mapModelToProps) {
                mapModelToProps = (mapModelToProps || (function (model) {
                    var _a;
                    return (_a = {}, _a[name] = model, _a);
                }));
                return function (Component) {
                    return function (props) {
                        var value = useModel(name);
                        var withProps = mapModelToProps(value);
                        return (React.createElement(Component, __assign({}, withProps, props)));
                    };
                };
            }
            function createWithModelDispatchers(fieldSuffix) {
                if (fieldSuffix === void 0) { fieldSuffix = 'Dispatchers'; }
                return function withModelDispatchers(name, mapModelDispatchersToProps) {
                    mapModelDispatchersToProps = (mapModelDispatchersToProps || (function (dispatch) {
                        var _a;
                        return (_a = {}, _a["" + name + fieldSuffix] = dispatch, _a);
                    }));
                    return function (Component) {
                        return function (props) {
                            var dispatchers = useModelDispatchers(name);
                            var withProps = mapModelDispatchersToProps(dispatchers);
                            return (React.createElement(Component, __assign({}, withProps, props)));
                        };
                    };
                };
            }
            var withModelDispatchers = createWithModelDispatchers();
            function createWithModelEffectsState(fieldSuffix) {
                if (fieldSuffix === void 0) { fieldSuffix = 'EffectsState'; }
                return function (name, mapModelEffectsStateToProps) {
                    mapModelEffectsStateToProps = (mapModelEffectsStateToProps || (function (effectsState) {
                        var _a;
                        return (_a = {}, _a["" + name + fieldSuffix] = effectsState, _a);
                    }));
                    return function (Component) {
                        return function (props) {
                            var value = useModelEffectsState(name);
                            var withProps = mapModelEffectsStateToProps(value);
                            return (React.createElement(Component, __assign({}, withProps, props)));
                        };
                    };
                };
            }
            var withModelEffectsState = createWithModelEffectsState();
            function withModelEffectsError(name, mapModelEffectsErrorToProps) {
                mapModelEffectsErrorToProps = (mapModelEffectsErrorToProps || (function (errors) {
                    var _a;
                    return (_a = {}, _a[name + "EffectsError"] = errors, _a);
                }));
                return function (Component) {
                    return function (props) {
                        var value = useModelEffectsError(name);
                        var withProps = mapModelEffectsErrorToProps(value);
                        return (React.createElement(Component, __assign({}, withProps, props)));
                    };
                };
            }
            function withModelEffectsLoading(name, mapModelEffectsLoadingToProps) {
                mapModelEffectsLoadingToProps = (mapModelEffectsLoadingToProps || (function (loadings) {
                    var _a;
                    return (_a = {}, _a[name + "EffectsLoading"] = loadings, _a);
                }));
                return function (Component) {
                    return function (props) {
                        var value = useModelEffectsLoading(name);
                        var withProps = mapModelEffectsLoadingToProps(value);
                        return (React.createElement(Component, __assign({}, withProps, props)));
                    };
                };
            }
            function getModelAPIs(name) {
                return {
                    useValue: function () { return useModel(name); },
                    useState: function () { return useModelState(name); },
                    useDispatchers: function () { return useModelDispatchers(name); },
                    useEffectsState: function () { return useModelEffectsState(name); },
                    useEffectsError: function () { return useModelEffectsError(name); },
                    useEffectsLoading: function () { return useModelEffectsLoading(name); },
                    getValue: function () { return getModel(name); },
                    getState: function () { return getModelState(name); },
                    getDispatchers: function () { return getModelDispatchers(name); },
                    withValue: function (mapToProps) { return withModel(name, mapToProps); },
                    withDispatchers: function (mapToProps) { return withModelDispatchers(name, mapToProps); },
                    withEffectsState: function (mapToProps) { return withModelEffectsState(name, mapToProps); },
                    withEffectsError: function (mapToProps) { return withModelEffectsError(name, mapToProps); },
                    withEffectsLoading: function (mapToProps) { return withModelEffectsLoading(name, mapToProps); },
                };
            }
            return {
                getModelAPIs: getModelAPIs,
                // Hooks
                useModel: useModel,
                useModelState: useModelState,
                useModelDispatchers: useModelDispatchers,
                useModelEffectsState: useModelEffectsState,
                useModelEffectsError: useModelEffectsError,
                useModelEffectsLoading: useModelEffectsLoading,
                // real time
                getModel: getModel,
                getModelState: getModelState,
                getModelDispatchers: getModelDispatchers,
                // Class component support
                withModel: withModel,
                withModelDispatchers: withModelDispatchers,
                withModelEffectsState: withModelEffectsState,
                withModelEffectsError: withModelEffectsError,
                withModelEffectsLoading: withModelEffectsLoading,
            };
        },
    };
});
