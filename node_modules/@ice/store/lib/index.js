var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import React from 'react';
import thunkMiddleware from 'redux-thunk';
import Icestore from './icestore';
import mergeConfig from './utils/mergeConfig';
import createProviderPlugin from './plugins/provider';
import createReduxHooksPlugin from './plugins/reduxHooks';
import createModelApisPlugin from './plugins/modelApis';
import createImmerPlugin from './plugins/immer';
import createLoadingPlugin from './plugins/loading';
import createErrorPlugin from './plugins/error';
import { checkModels } from './utils/checkModels';
import appendReducers from './utils/appendReducers';
// incrementer used to provide a store name if none exists
var count = 0;
/**
 * createOriginStore
 *
 * generates a Icestore with a set configuration
 * @param config
 */
var init = function (initConfig) {
    if (initConfig === void 0) { initConfig = {}; }
    var name = initConfig.name || count.toString();
    count += 1;
    var config = mergeConfig(__assign(__assign({}, initConfig), { name: name }));
    return new Icestore(config).init();
};
/**
 * createStore
 *
 * generates a preset Icestore
 * @param models
 * @param initConfig
 */
export var createStore = function (models, initConfig) {
    var _a = initConfig || {}, disableImmer = _a.disableImmer, disableLoading = _a.disableLoading, disableError = _a.disableError, _b = _a.plugins, plugins = _b === void 0 ? [] : _b, _c = _a.redux, redux = _c === void 0 ? {} : _c;
    var middlewares = redux.middlewares || [];
    var context = React.createContext(null);
    // defaults middlewares
    middlewares.push(thunkMiddleware);
    // defaults plugins
    plugins.push(createProviderPlugin({ context: context }));
    plugins.push(createReduxHooksPlugin({ context: context }));
    plugins.push(createModelApisPlugin());
    // https://github.com/ice-lab/icestore/issues/94
    // TODO: fix error & loading plugin immer problem
    var immerBlacklist = [];
    if (!disableLoading) {
        plugins.push(createLoadingPlugin());
        immerBlacklist.push('loading');
    }
    if (!disableError) {
        plugins.push(createErrorPlugin());
        immerBlacklist.push('error');
    }
    if (!disableImmer) {
        plugins.push(createImmerPlugin({ blacklist: immerBlacklist }));
    }
    // TODO: disable in production?
    checkModels(models);
    // compatibility handling
    var wrappedModels = appendReducers(models);
    var store = init({
        models: wrappedModels,
        plugins: plugins,
        redux: __assign(__assign({}, redux), { middlewares: middlewares }),
    });
    return store;
};
export var withModel = function (model, mapModelToProps, initConfig) {
    var _a;
    var modelName = 'model';
    mapModelToProps = (mapModelToProps || (function (modelApis) {
        var _a;
        return (_a = {}, _a[modelName] = modelApis, _a);
    }));
    var store = createStore((_a = {}, _a[modelName] = model, _a), initConfig);
    var Provider = store.Provider, getModelAPIs = store.getModelAPIs;
    var modelApis = getModelAPIs(modelName);
    var withProps = mapModelToProps(modelApis);
    return function (Component) {
        return function (props) {
            return (React.createElement(Provider, null,
                React.createElement(Component, __assign({}, withProps, props))));
        };
    };
};
export default createStore;
export * from './types';
