var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import validate from './validate';
var merge = function (original, next) {
    return next ? __assign(__assign({}, next), (original || {})) : original || {};
};
var isObject = function (obj) {
    return Array.isArray(obj) || typeof obj !== 'object';
};
/**
 * mergeConfig
 *
 * merge init configs together
 */
export default (function (initConfig) {
    var config = __assign(__assign({ name: initConfig.name, models: {}, plugins: [] }, initConfig), { redux: __assign(__assign({ reducers: {}, rootReducers: {}, enhancers: [], middlewares: [] }, initConfig.redux), { devtoolOptions: __assign({ name: initConfig.name }, (initConfig.redux && initConfig.redux.devtoolOptions
                ? initConfig.redux.devtoolOptions
                : {})) }) });
    if (process.env.NODE_ENV !== 'production') {
        validate([
            [!Array.isArray(config.plugins), 'init config.plugins must be an array'],
            [isObject(config.models), 'init config.models must be an object'],
            [
                isObject(config.redux.reducers),
                'init config.redux.reducers must be an object',
            ],
            [
                !Array.isArray(config.redux.middlewares),
                'init config.redux.middlewares must be an array',
            ],
            [
                !Array.isArray(config.redux.enhancers),
                'init config.redux.enhancers must be an array of functions',
            ],
            [
                config.redux.combineReducers &&
                    typeof config.redux.combineReducers !== 'function',
                'init config.redux.combineReducers must be a function',
            ],
            [
                config.redux.createStore &&
                    typeof config.redux.createStore !== 'function',
                'init config.redux.createStore must be a function',
            ],
        ]);
    }
    // defaults
    for (var _i = 0, _a = config.plugins; _i < _a.length; _i++) {
        var plugin = _a[_i];
        if (plugin.config) {
            // models
            var models = merge(config.models, plugin.config.models);
            config.models = models;
            // plugins
            config.plugins = __spreadArrays(config.plugins, (plugin.config.plugins || []));
            // redux
            if (plugin.config.redux) {
                config.redux.initialStates = merge(config.redux.initialStates, plugin.config.redux.initialStates);
                config.redux.reducers = merge(config.redux.reducers, plugin.config.redux.reducers);
                config.redux.rootReducers = merge(config.redux.rootReducers, plugin.config.redux.reducers);
                config.redux.enhancers = __spreadArrays(config.redux.enhancers, (plugin.config.redux.enhancers || []));
                config.redux.middlewares = __spreadArrays(config.redux.middlewares, (plugin.config.redux.middlewares || []));
                config.redux.combineReducers =
                    config.redux.combineReducers || plugin.config.redux.combineReducers;
                config.redux.createStore =
                    config.redux.createStore || plugin.config.redux.createStore;
            }
        }
    }
    return config;
});
