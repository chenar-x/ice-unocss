"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs-extra");
const chalk_1 = require("chalk");
const fg = require("fast-glob");
const hijackWebpack_1 = require("../utils/hijackWebpack");
const loadConfig_1 = require("../utils/loadConfig");
const assert = require("assert");
const _ = require("lodash");
const camelCase = require("camelcase");
const deepmerge = require("deepmerge");
const log = require("../utils/log");
const PKG_FILE = 'package.json';
const USER_CONFIG_FILE = ['build.json', 'build.config.(js|ts)'];
const PLUGIN_CONTEXT_KEY = [
    'command',
    'commandArgs',
    'rootDir',
    'userConfig',
    'originalUserConfig',
    'pkg',
    'webpack',
];
const VALIDATION_MAP = {
    string: 'isString',
    number: 'isNumber',
    array: 'isArray',
    object: 'isObject',
    boolean: 'isBoolean',
};
const BUILTIN_CLI_OPTIONS = [
    { name: 'port', commands: ['start'] },
    { name: 'host', commands: ['start'] },
    { name: 'disableAsk', commands: ['start'] },
    { name: 'config', commands: ['start', 'build', 'test'] },
];
const mergeConfig = (currentValue, newValue) => {
    // only merge when currentValue and newValue is object and array
    const isBothArray = Array.isArray(currentValue) && Array.isArray(newValue);
    const isBothObject = _.isPlainObject(currentValue) && _.isPlainObject(newValue);
    if (isBothArray || isBothObject) {
        return deepmerge(currentValue, newValue);
    }
    else {
        return newValue;
    }
};
class Context {
    constructor(options) {
        this.commandModules = {};
        this.registerConfig = (type, args, parseName) => {
            const registerKey = `${type}Registration`;
            if (!this[registerKey]) {
                throw new Error(`unknown register type: ${type}, use available types (userConfig or cliOption) instead`);
            }
            const configArr = _.isArray(args) ? args : [args];
            configArr.forEach((conf) => {
                const confName = parseName ? parseName(conf.name) : conf.name;
                if (this[registerKey][confName]) {
                    throw new Error(`${conf.name} already registered in ${type}`);
                }
                this[registerKey][confName] = conf;
                // set default userConfig
                if (type === 'userConfig' &&
                    _.isUndefined(this.userConfig[confName]) &&
                    Object.prototype.hasOwnProperty.call(conf, 'defaultValue')) {
                    this.userConfig[confName] = conf.defaultValue;
                }
            });
        };
        this.getProjectFile = (fileName) => {
            const configPath = path.resolve(this.rootDir, fileName);
            let config = {};
            if (fs.existsSync(configPath)) {
                try {
                    config = fs.readJsonSync(configPath);
                }
                catch (err) {
                    log.info('CONFIG', `Fail to load config file ${configPath}, use empty object`);
                }
            }
            return config;
        };
        this.getUserConfig = () => __awaiter(this, void 0, void 0, function* () {
            const { config } = this.commandArgs;
            let configPath = '';
            if (config) {
                configPath = path.isAbsolute(config)
                    ? config
                    : path.resolve(this.rootDir, config);
            }
            else {
                const [defaultUserConfig] = yield fg(USER_CONFIG_FILE, { cwd: this.rootDir, absolute: true });
                configPath = defaultUserConfig;
            }
            let userConfig = {
                plugins: [],
            };
            if (configPath && fs.existsSync(configPath)) {
                try {
                    userConfig = yield loadConfig_1.default(configPath, log);
                }
                catch (err) {
                    log.info('CONFIG', `Fail to load config file ${configPath}`);
                    log.error('CONFIG', err.stack || err.toString());
                    process.exit(1);
                }
            }
            else {
                log.error('CONFIG', `config file${`(${configPath})` || ''} is not exist`);
                process.exit(1);
            }
            return this.mergeModeConfig(userConfig);
        });
        this.mergeModeConfig = (userConfig) => {
            const { mode } = this.commandArgs;
            // modify userConfig by userConfig.modeConfig
            if (userConfig.modeConfig &&
                mode &&
                userConfig.modeConfig[mode]) {
                const _a = userConfig.modeConfig[mode], { plugins } = _a, basicConfig = __rest(_a, ["plugins"]);
                const userPlugins = [...userConfig.plugins];
                if (Array.isArray(plugins)) {
                    const pluginKeys = userPlugins.map(pluginInfo => {
                        return Array.isArray(pluginInfo) ? pluginInfo[0] : pluginInfo;
                    });
                    plugins.forEach(pluginInfo => {
                        const [pluginName] = Array.isArray(pluginInfo)
                            ? pluginInfo
                            : [pluginInfo];
                        const pluginIndex = pluginKeys.indexOf(pluginName);
                        if (pluginIndex > -1) {
                            // overwrite plugin info by modeConfig
                            userPlugins[pluginIndex] = pluginInfo;
                        }
                        else {
                            // push new plugin added by modeConfig
                            userPlugins.push(pluginInfo);
                        }
                    });
                }
                return Object.assign(Object.assign(Object.assign({}, userConfig), basicConfig), { plugins: userPlugins });
            }
            return userConfig;
        };
        this.resolvePlugins = (builtInPlugins) => {
            const userPlugins = [
                ...builtInPlugins,
                ...(this.userConfig.plugins || []),
            ].map((pluginInfo) => {
                let fn;
                if (_.isFunction(pluginInfo)) {
                    return {
                        fn: pluginInfo,
                        options: {},
                    };
                }
                const plugins = Array.isArray(pluginInfo)
                    ? pluginInfo
                    : [pluginInfo, undefined];
                const pluginResolveDir = process.env.EXTRA_PLUGIN_DIR
                    ? [process.env.EXTRA_PLUGIN_DIR, this.rootDir]
                    : [this.rootDir];
                const pluginPath = path.isAbsolute(plugins[0])
                    ? plugins[0]
                    : require.resolve(plugins[0], { paths: pluginResolveDir });
                const options = plugins[1];
                try {
                    fn = require(pluginPath); // eslint-disable-line
                }
                catch (err) {
                    log.error('CONFIG', `Fail to load plugin ${pluginPath}`);
                    log.error('CONFIG', err.stack || err.toString());
                    process.exit(1);
                }
                return {
                    name: plugins[0],
                    pluginPath,
                    fn: fn.default || fn || (() => { }),
                    options,
                };
            });
            return userPlugins;
        };
        this.getAllPlugin = (dataKeys = ['pluginPath', 'options', 'name']) => {
            return this.plugins.map((pluginInfo) => {
                // filter fn to avoid loop
                return _.pick(pluginInfo, dataKeys);
            });
        };
        this.registerTask = (name, chainConfig) => {
            const exist = this.configArr.find((v) => v.name === name);
            if (!exist) {
                this.configArr.push({
                    name,
                    chainConfig,
                    modifyFunctions: [],
                });
            }
            else {
                throw new Error(`[Error] config '${name}' already exists!`);
            }
        };
        this.cancelTask = name => {
            if (this.cancelTaskNames.includes(name)) {
                log.info('TASK', `task ${name} has already been canceled`);
            }
            else {
                this.cancelTaskNames.push(name);
            }
        };
        this.registerMethod = (name, fn, options) => {
            if (this.methodRegistration[name]) {
                throw new Error(`[Error] method '${name}' already registered`);
            }
            else {
                const registration = [fn, options];
                this.methodRegistration[name] = registration;
            }
        };
        this.applyMethod = (config, ...args) => {
            const [methodName, pluginName] = Array.isArray(config) ? config : [config];
            if (this.methodRegistration[methodName]) {
                const [registerMethod, methodOptions] = this.methodRegistration[methodName];
                if (methodOptions === null || methodOptions === void 0 ? void 0 : methodOptions.pluginName) {
                    return registerMethod(pluginName)(...args);
                }
                else {
                    return registerMethod(...args);
                }
            }
            else {
                throw new Error(`apply unknown method ${methodName}`);
            }
        };
        this.hasMethod = name => {
            return !!this.methodRegistration[name];
        };
        this.modifyUserConfig = (configKey, value, options) => {
            const errorMsg = 'config plugins is not support to be modified';
            const { deepmerge: mergeInDeep } = options || {};
            if (typeof configKey === 'string') {
                if (configKey === 'plugins') {
                    throw new Error(errorMsg);
                }
                const configPath = configKey.split('.');
                const originalValue = _.get(this.userConfig, configPath);
                const newValue = typeof value !== 'function' ? value : value(originalValue);
                _.set(this.userConfig, configPath, mergeInDeep ? mergeConfig(originalValue, newValue) : newValue);
            }
            else if (typeof configKey === 'function') {
                const modifiedValue = configKey(this.userConfig);
                if (_.isPlainObject(modifiedValue)) {
                    if (Object.prototype.hasOwnProperty.call(modifiedValue, 'plugins')) {
                        // remove plugins while it is not support to be modified
                        log.verbose('[modifyUserConfig]', 'delete plugins of user config while it is not support to be modified');
                        delete modifiedValue.plugins;
                    }
                    Object.keys(modifiedValue).forEach(modifiedConfigKey => {
                        const originalValue = this.userConfig[modifiedConfigKey];
                        this.userConfig[modifiedConfigKey] = mergeInDeep ? mergeConfig(originalValue, modifiedValue[modifiedConfigKey]) : modifiedValue[modifiedConfigKey];
                    });
                }
                else {
                    throw new Error(`modifyUserConfig must return a plain object`);
                }
            }
        };
        this.modifyConfigRegistration = (...args) => {
            this.modifyConfigRegistrationCallbacks.push(args);
        };
        this.modifyCliRegistration = (...args) => {
            this.modifyCliRegistrationCallbacks.push(args);
        };
        this.getAllTask = () => {
            return this.configArr.map(v => v.name);
        };
        this.onGetWebpackConfig = (...args) => {
            this.modifyConfigFns.push(args);
        };
        this.onGetJestConfig = (fn) => {
            this.modifyJestConfig.push(fn);
        };
        this.runJestConfig = (jestConfig) => {
            let result = jestConfig;
            for (const fn of this.modifyJestConfig) {
                result = fn(result);
            }
            return result;
        };
        this.onHook = (key, fn) => {
            if (!Array.isArray(this.eventHooks[key])) {
                this.eventHooks[key] = [];
            }
            this.eventHooks[key].push(fn);
        };
        this.applyHook = (key, opts = {}) => __awaiter(this, void 0, void 0, function* () {
            const hooks = this.eventHooks[key] || [];
            for (const fn of hooks) {
                // eslint-disable-next-line no-await-in-loop
                yield fn(opts);
            }
        });
        this.setValue = (key, value) => {
            this.internalValue[key] = value;
        };
        this.getValue = (key) => {
            return this.internalValue[key];
        };
        this.registerUserConfig = (args) => {
            this.registerConfig('userConfig', args);
        };
        this.hasRegistration = (name, type = 'userConfig') => {
            const mappedType = type === 'cliOption' ? 'cliOptionRegistration' : 'userConfigRegistration';
            return Object.keys(this[mappedType] || {}).includes(name);
        };
        this.registerCliOption = (args) => {
            this.registerConfig('cliOption', args, name => {
                return camelCase(name, { pascalCase: false });
            });
        };
        this.resolveConfig = () => __awaiter(this, void 0, void 0, function* () {
            this.userConfig = yield this.getUserConfig();
            // shallow copy of userConfig while userConfig may be modified
            this.originalUserConfig = Object.assign({}, this.userConfig);
            const { plugins = [], getBuiltInPlugins = () => [] } = this.options;
            // run getBuiltInPlugins before resolve webpack while getBuiltInPlugins may add require hook for webpack
            const builtInPlugins = [
                ...plugins,
                ...getBuiltInPlugins(this.userConfig),
            ];
            // custom webpack
            const webpackInstancePath = this.userConfig.customWebpack
                ? require.resolve('webpack', { paths: [this.rootDir] })
                : 'webpack';
            this.webpack = require(webpackInstancePath);
            if (this.userConfig.customWebpack) {
                hijackWebpack_1.default(this.webpack, this.rootDir);
            }
            this.checkPluginValue(builtInPlugins); // check plugins property
            this.plugins = this.resolvePlugins(builtInPlugins);
        });
        this.runPlugins = () => __awaiter(this, void 0, void 0, function* () {
            for (const pluginInfo of this.plugins) {
                const { fn, options, name: pluginName } = pluginInfo;
                const pluginContext = _.pick(this, PLUGIN_CONTEXT_KEY);
                const applyMethod = (methodName, ...args) => {
                    return this.applyMethod([methodName, pluginName], ...args);
                };
                const pluginAPI = {
                    log,
                    context: pluginContext,
                    registerTask: this.registerTask,
                    getAllTask: this.getAllTask,
                    getAllPlugin: this.getAllPlugin,
                    cancelTask: this.cancelTask,
                    onGetWebpackConfig: this.onGetWebpackConfig,
                    onGetJestConfig: this.onGetJestConfig,
                    onHook: this.onHook,
                    setValue: this.setValue,
                    getValue: this.getValue,
                    registerUserConfig: this.registerUserConfig,
                    hasRegistration: this.hasRegistration,
                    registerCliOption: this.registerCliOption,
                    registerMethod: this.registerMethod,
                    applyMethod,
                    hasMethod: this.hasMethod,
                    modifyUserConfig: this.modifyUserConfig,
                    modifyConfigRegistration: this.modifyConfigRegistration,
                    modifyCliRegistration: this.modifyCliRegistration,
                };
                // eslint-disable-next-line no-await-in-loop
                yield fn(pluginAPI, options);
            }
        });
        this.checkPluginValue = (plugins) => {
            let flag;
            if (!_.isArray(plugins)) {
                flag = false;
            }
            else {
                flag = plugins.every(v => {
                    let correct = _.isArray(v) || _.isString(v) || _.isFunction(v);
                    if (correct && _.isArray(v)) {
                        correct = _.isString(v[0]);
                    }
                    return correct;
                });
            }
            if (!flag) {
                throw new Error('plugins did not pass validation');
            }
        };
        this.runConfigModification = () => __awaiter(this, void 0, void 0, function* () {
            const callbackRegistrations = [
                'modifyConfigRegistrationCallbacks',
                'modifyCliRegistrationCallbacks',
            ];
            callbackRegistrations.forEach(registrationKey => {
                const registrations = this[registrationKey];
                registrations.forEach(([name, callback]) => {
                    const modifyAll = _.isFunction(name);
                    const configRegistrations = this[registrationKey === 'modifyConfigRegistrationCallbacks'
                        ? 'userConfigRegistration'
                        : 'cliOptionRegistration'];
                    if (modifyAll) {
                        const modifyFunction = name;
                        const modifiedResult = modifyFunction(configRegistrations);
                        Object.keys(modifiedResult).forEach(configKey => {
                            configRegistrations[configKey] = Object.assign(Object.assign({}, (configRegistrations[configKey] || {})), modifiedResult[configKey]);
                        });
                    }
                    else if (typeof name === 'string') {
                        if (!configRegistrations[name]) {
                            throw new Error(`Config key '${name}' is not registered`);
                        }
                        const configRegistration = configRegistrations[name];
                        configRegistrations[name] = Object.assign(Object.assign({}, configRegistration), callback(configRegistration));
                    }
                });
            });
        });
        this.runUserConfig = () => __awaiter(this, void 0, void 0, function* () {
            for (const configInfoKey in this.userConfig) {
                if (!['plugins', 'customWebpack'].includes(configInfoKey)) {
                    const configInfo = this.userConfigRegistration[configInfoKey];
                    if (!configInfo) {
                        throw new Error(`[Config File] Config key '${configInfoKey}' is not supported`);
                    }
                    const { name, validation, ignoreTasks } = configInfo;
                    const configValue = this.userConfig[name];
                    if (validation) {
                        let validationInfo;
                        if (_.isString(validation)) {
                            // split validation string
                            const supportTypes = validation.split('|');
                            const validateResult = supportTypes.some(supportType => {
                                const fnName = VALIDATION_MAP[supportType];
                                if (!fnName) {
                                    throw new Error(`validation does not support ${supportType}`);
                                }
                                return _[fnName](configValue);
                            });
                            assert(validateResult, `Config ${name} should be ${validation}, but got ${configValue}`);
                        }
                        else {
                            // eslint-disable-next-line no-await-in-loop
                            validationInfo = yield validation(configValue);
                            assert(validationInfo, `${name} did not pass validation, result: ${validationInfo}`);
                        }
                    }
                    if (configInfo.configWebpack) {
                        // eslint-disable-next-line no-await-in-loop
                        yield this.runConfigWebpack(configInfo.configWebpack, configValue, ignoreTasks);
                    }
                }
            }
        });
        this.runCliOption = () => __awaiter(this, void 0, void 0, function* () {
            for (const cliOpt in this.commandArgs) {
                // allow all jest option when run command test
                if (this.command !== 'test' || cliOpt !== 'jestArgv') {
                    const { commands, name, configWebpack, ignoreTasks } = this.cliOptionRegistration[cliOpt] || {};
                    if (!name || !(commands || []).includes(this.command)) {
                        throw new Error(`cli option '${cliOpt}' is not supported when run command '${this.command}'`);
                    }
                    if (configWebpack) {
                        // eslint-disable-next-line no-await-in-loop
                        yield this.runConfigWebpack(configWebpack, this.commandArgs[cliOpt], ignoreTasks);
                    }
                }
            }
        });
        this.runWebpackFunctions = () => __awaiter(this, void 0, void 0, function* () {
            this.modifyConfigFns.forEach(([name, func]) => {
                const isAll = _.isFunction(name);
                if (isAll) {
                    // modify all
                    this.configArr.forEach(config => {
                        config.modifyFunctions.push(name);
                    });
                }
                else {
                    // modify named config
                    this.configArr.forEach(config => {
                        if (config.name === name) {
                            config.modifyFunctions.push(func);
                        }
                    });
                }
            });
            for (const configInfo of this.configArr) {
                for (const func of configInfo.modifyFunctions) {
                    // eslint-disable-next-line no-await-in-loop
                    yield func(configInfo.chainConfig);
                }
            }
        });
        this.setUp = () => __awaiter(this, void 0, void 0, function* () {
            yield this.resolveConfig();
            yield this.runPlugins();
            yield this.runConfigModification();
            yield this.runUserConfig();
            yield this.runWebpackFunctions();
            yield this.runCliOption();
            // filter webpack config by cancelTaskNames
            this.configArr = this.configArr.filter(config => !this.cancelTaskNames.includes(config.name));
            return this.configArr;
        });
        this.getWebpackConfig = () => {
            return this.configArr;
        };
        this.run = (options) => __awaiter(this, void 0, void 0, function* () {
            const { command, commandArgs } = this;
            log.verbose('OPTIONS', `${command} cliOptions: ${JSON.stringify(commandArgs, null, 2)}`);
            try {
                yield this.setUp();
            }
            catch (err) {
                log.error('CONFIG', chalk_1.default.red('Failed to get config.'));
                yield this.applyHook(`error`, { err });
                throw err;
            }
            const commandModule = this.getCommandModule({ command, commandArgs, userConfig: this.userConfig });
            return commandModule(this, options);
        });
        const { command, rootDir = process.cwd(), args = {}, } = options || {};
        this.options = options;
        this.command = command;
        this.commandArgs = args;
        this.rootDir = rootDir;
        /**
         * config array
         * {
         *   name,
         *   chainConfig,
         *   webpackFunctions,
         * }
         */
        this.configArr = [];
        this.modifyConfigFns = [];
        this.modifyJestConfig = [];
        this.modifyConfigRegistrationCallbacks = [];
        this.modifyCliRegistrationCallbacks = [];
        this.eventHooks = {}; // lifecycle functions
        this.internalValue = {}; // internal value shared between plugins
        this.userConfigRegistration = {};
        this.cliOptionRegistration = {};
        this.methodRegistration = {};
        this.cancelTaskNames = [];
        this.pkg = this.getProjectFile(PKG_FILE);
        // register builtin options
        this.registerCliOption(BUILTIN_CLI_OPTIONS);
    }
    runConfigWebpack(fn, configValue, ignoreTasks) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const webpackConfigInfo of this.configArr) {
                const taskName = webpackConfigInfo.name;
                let ignoreConfig = false;
                if (Array.isArray(ignoreTasks)) {
                    ignoreConfig = ignoreTasks.some(ignoreTask => new RegExp(ignoreTask).exec(taskName));
                }
                if (!ignoreConfig) {
                    const userConfigContext = Object.assign(Object.assign({}, _.pick(this, PLUGIN_CONTEXT_KEY)), { taskName });
                    // eslint-disable-next-line no-await-in-loop
                    yield fn(webpackConfigInfo.chainConfig, configValue, userConfigContext);
                }
            }
        });
    }
    registerCommandModules(moduleKey, module) {
        if (this.commandModules[moduleKey]) {
            log.warn('CONFIG', `command module ${moduleKey} already been registered`);
        }
        this.commandModules[moduleKey] = module;
    }
    getCommandModule(options) {
        const { command } = options;
        if (this.commandModules[command]) {
            return this.commandModules[command];
        }
        else {
            throw new Error(`command ${command} is not support`);
        }
    }
    ;
}
exports.default = Context;
