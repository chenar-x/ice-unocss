"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const chalk_1 = require("chalk");
const webpackStats_1 = require("../utils/webpackStats");
const deepmerge = require("deepmerge");
const prepareURLs = require("../utils/prepareURLs");
const log = require("../utils/log");
module.exports = function (context, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const { eject } = options || {};
        const configArr = context.getWebpackConfig();
        const { command, commandArgs, webpack, applyHook } = context;
        yield applyHook(`before.${command}.load`, { args: commandArgs, webpackConfig: configArr });
        // eject config
        if (eject) {
            return configArr;
        }
        if (!configArr.length) {
            const errorMsg = 'No webpack config found.';
            log.warn('CONFIG', errorMsg);
            yield applyHook(`error`, { err: new Error(errorMsg) });
            return;
        }
        let serverUrl = '';
        let devServerConfig = {
            port: commandArgs.port || 3333,
            host: commandArgs.host || '0.0.0.0',
            https: commandArgs.https || false,
        };
        for (const item of configArr) {
            const { chainConfig } = item;
            const config = chainConfig.toConfig();
            if (config.devServer) {
                devServerConfig = deepmerge(devServerConfig, config.devServer);
            }
            // if --port or process.env.PORT has been set, overwrite option port
            if (process.env.USE_CLI_PORT) {
                devServerConfig.port = commandArgs.port;
            }
        }
        const webpackConfig = configArr.map(v => v.chainConfig.toConfig());
        yield applyHook(`before.${command}.run`, {
            args: commandArgs,
            config: webpackConfig,
        });
        let compiler;
        try {
            compiler = webpack(webpackConfig);
        }
        catch (err) {
            log.error('CONFIG', chalk_1.default.red('Failed to load webpack config.'));
            yield applyHook(`error`, { err });
            throw err;
        }
        const protocol = devServerConfig.https ? 'https' : 'http';
        const urls = prepareURLs(protocol, devServerConfig.host, devServerConfig.port);
        serverUrl = urls.localUrlForBrowser;
        let isFirstCompile = true;
        // typeof(stats) is webpack.compilation.MultiStats
        compiler.hooks.done.tap('compileHook', (stats) => __awaiter(this, void 0, void 0, function* () {
            const isSuccessful = webpackStats_1.default({
                urls,
                stats,
                isFirstCompile,
            });
            if (isSuccessful) {
                isFirstCompile = false;
            }
            yield applyHook(`after.${command}.compile`, {
                url: serverUrl,
                urls,
                isFirstCompile,
                stats,
            });
        }));
        let devServer;
        // require webpack-dev-server after context setup
        // context may hijack webpack resolve
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const DevServer = require('webpack-dev-server');
        // static method getFreePort in v4
        if (DevServer.getFreePort) {
            devServer = new DevServer(devServerConfig, compiler);
        }
        else {
            devServer = new DevServer(compiler, devServerConfig);
        }
        yield applyHook(`before.${command}.devServer`, {
            url: serverUrl,
            urls,
            devServer,
        });
        if (devServer.startCallback) {
            devServer.startCallback(() => {
                applyHook(`after.${command}.devServer`, {
                    url: serverUrl,
                    urls,
                    devServer,
                });
            });
        }
        else {
            devServer.listen(devServerConfig.port, devServerConfig.host, (err) => __awaiter(this, void 0, void 0, function* () {
                if (err) {
                    log.info('WEBPACK', chalk_1.default.red('[ERR]: Failed to start webpack dev server'));
                    log.error('WEBPACK', (err.stack || err.toString()));
                }
                yield applyHook(`after.${command}.devServer`, {
                    url: serverUrl,
                    urls,
                    devServer,
                    err,
                });
            }));
        }
        return devServer;
    });
};
