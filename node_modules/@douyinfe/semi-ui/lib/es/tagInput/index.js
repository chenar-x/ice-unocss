import _isFunction from "lodash/isFunction";
import _isUndefined from "lodash/isUndefined";
import _isNull from "lodash/isNull";
import _isArray from "lodash/isArray";
import _isString from "lodash/isString";
import _noop from "lodash/noop";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import React from 'react';
import cls from 'classnames';
import PropTypes from 'prop-types';
import { cssClasses, strings } from '@douyinfe/semi-foundation/lib/es/tagInput/constants';
import '@douyinfe/semi-foundation/lib/es/tagInput/tagInput.css';
import TagInputFoundation from '@douyinfe/semi-foundation/lib/es/tagInput/foundation';
import BaseComponent from '../_base/baseComponent';
import Tag from '../tag';
import Input from '../input';
import Popover from '../popover';
import Paragraph from '../typography/paragraph';
import { IconClear } from '@douyinfe/semi-icons';
const prefixCls = cssClasses.PREFIX;

class TagInput extends BaseComponent {
  constructor(props) {
    super(props);

    this.handleInputChange = e => {
      this.foundation.handleInputChange(e);
    };

    this.handleKeyDown = e => {
      this.foundation.handleKeyDown(e);
    };

    this.handleInputFocus = e => {
      this.foundation.handleInputFocus(e);
    };

    this.handleInputBlur = e => {
      this.foundation.handleInputBlur(e);
    };

    this.handleClearBtn = e => {
      this.foundation.handleClearBtn(e);
    };

    this.handleTagClose = idx => {
      this.foundation.handleTagClose(idx);
    };

    this.handleInputMouseLeave = e => {
      this.foundation.handleInputMouseLeave();
    };

    this.handleInputMouseEnter = e => {
      this.foundation.handleInputMouseEnter();
    };

    this.foundation = new TagInputFoundation(this.adapter);
    this.state = {
      tagsArray: props.defaultValue || [],
      inputValue: '',
      focusing: false,
      hovering: false
    };
    this.inputRef = /*#__PURE__*/React.createRef();
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    const {
      value,
      inputValue
    } = nextProps;
    return {
      tagsArray: _isArray(value) ? value : prevState.tagsArray,
      inputValue: _isString(inputValue) ? inputValue : prevState.inputValue
    };
  }

  get adapter() {
    return _Object$assign(_Object$assign({}, super.adapter), {
      setInputValue: inputValue => {
        this.setState({
          inputValue
        });
      },
      setTagsArray: tagsArray => {
        this.setState({
          tagsArray
        });
      },
      setFocusing: focusing => {
        this.setState({
          focusing
        });
      },
      setHovering: hovering => {
        this.setState({
          hovering
        });
      },
      notifyBlur: e => {
        this.props.onBlur(e);
      },
      notifyFocus: e => {
        this.props.onFocus(e);
      },
      notifyInputChange: (v, e) => {
        this.props.onInputChange(v, e);
      },
      notifyTagChange: v => {
        this.props.onChange(v);
      },
      notifyTagAdd: v => {
        this.props.onAdd(v);
      },
      notifyTagRemove: (v, idx) => {
        this.props.onRemove(v, idx);
      },
      notifyKeyDown: e => {
        this.props.onKeyDown(e);
      }
    });
  }

  componentDidMount() {
    const {
      disabled,
      autoFocus
    } = this.props;

    if (!disabled && autoFocus) {
      this.inputRef.current.focus();
    }
  }

  renderClearBtn() {
    const {
      hovering,
      tagsArray,
      inputValue
    } = this.state;
    const {
      showClear,
      disabled
    } = this.props;
    const clearCls = cls("".concat(prefixCls, "-clearBtn"), {
      ["".concat(prefixCls, "-clearBtn-invisible")]: !hovering || inputValue === '' && tagsArray.length === 0 || disabled
    });

    if (showClear) {
      return /*#__PURE__*/React.createElement("div", {
        className: clearCls,
        onClick: e => this.handleClearBtn(e)
      }, /*#__PURE__*/React.createElement(IconClear, null));
    }

    return null;
  }

  renderPrefix() {
    const {
      prefix
    } = this.props;

    if (_isNull(prefix) || _isUndefined(prefix)) {
      return null;
    }

    const prefixWrapperCls = cls("".concat(prefixCls, "-prefix"), {
      ["".concat(prefixCls, "-prefix-text")]: prefix && _isString(prefix),
      // eslint-disable-next-line max-len
      ["".concat(prefixCls, "-prefix-icon")]: /*#__PURE__*/React.isValidElement(prefix) && !(prefix && _isString(prefix))
    });
    return /*#__PURE__*/React.createElement("div", {
      className: prefixWrapperCls
    }, prefix);
  }

  renderSuffix() {
    const {
      suffix
    } = this.props;

    if (_isNull(suffix) || _isUndefined(suffix)) {
      return null;
    }

    const suffixWrapperCls = cls("".concat(prefixCls, "-suffix"), {
      ["".concat(prefixCls, "-suffix-text")]: suffix && _isString(suffix),
      // eslint-disable-next-line max-len
      ["".concat(prefixCls, "-suffix-icon")]: /*#__PURE__*/React.isValidElement(suffix) && !(suffix && _isString(suffix))
    });
    return /*#__PURE__*/React.createElement("div", {
      className: suffixWrapperCls
    }, suffix);
  }

  renderTags() {
    var _context;

    const {
      size,
      disabled,
      renderTagItem,
      maxTagCount,
      showContentTooltip,
      showRestTagsPopover,
      restTagsPopoverProps = {}
    } = this.props;
    const {
      tagsArray
    } = this.state;
    const tagCls = cls("".concat(prefixCls, "-wrapper-tag"), {
      [_concatInstanceProperty(_context = "".concat(prefixCls, "-wrapper-tag-size-")).call(_context, size)]: size
    });
    const typoCls = cls("".concat(prefixCls, "-wrapper-typo"), {
      ["".concat(prefixCls, "-wrapper-typo-disabled")]: disabled
    });
    const spanNotWithPopoverCls = cls("".concat(prefixCls, "-wrapper-n"), {
      ["".concat(prefixCls, "-wrapper-n-disabled")]: disabled
    });
    const restTags = [];
    const tags = [];

    _forEachInstanceProperty(tagsArray).call(tagsArray, (value, index) => {
      let item = null;

      if (_isFunction(renderTagItem)) {
        item = renderTagItem(value, index);
      } else {
        var _context2;

        item = /*#__PURE__*/React.createElement(Tag, {
          className: tagCls,
          color: "white",
          size: size === 'small' ? 'small' : 'large',
          type: "light",
          onClose: () => {
            !disabled && this.handleTagClose(index);
          },
          closable: !disabled,
          key: _concatInstanceProperty(_context2 = "".concat(index)).call(_context2, value),
          visible: true
        }, /*#__PURE__*/React.createElement(Paragraph, {
          className: typoCls,
          ellipsis: {
            showTooltip: showContentTooltip,
            rows: 1
          }
        }, value));
      }

      if (maxTagCount && index >= maxTagCount) {
        restTags.push(item);
      } else {
        tags.push(item);
      }
    });

    return /*#__PURE__*/React.createElement(React.Fragment, null, tags, restTags.length > 0 && (showRestTagsPopover && !disabled ? /*#__PURE__*/React.createElement(Popover, _Object$assign({
      content: restTags,
      showArrow: true,
      trigger: "hover",
      position: "top",
      autoAdjustOverflow: true
    }, restTagsPopoverProps), /*#__PURE__*/React.createElement("span", {
      className: cls("".concat(prefixCls, "-wrapper-n"))
    }, "+", tagsArray.length - maxTagCount)) : /*#__PURE__*/React.createElement("span", {
      className: spanNotWithPopoverCls
    }, "+".concat(tagsArray.length - maxTagCount))));
  }

  blur() {
    this.inputRef.current.blur();
  }

  focus() {
    this.inputRef.current.focus();
  }

  render() {
    const {
      size,
      style,
      className,
      disabled,
      placeholder,
      validateStatus
    } = this.props;
    const {
      focusing,
      hovering,
      tagsArray,
      inputValue
    } = this.state;
    const tagInputCls = cls(prefixCls, className, {
      ["".concat(prefixCls, "-focus")]: focusing,
      ["".concat(prefixCls, "-disabled")]: disabled,
      ["".concat(prefixCls, "-hover")]: hovering && !disabled,
      ["".concat(prefixCls, "-error")]: validateStatus === 'error',
      ["".concat(prefixCls, "-warning")]: validateStatus === 'warning'
    });
    const inputCls = cls("".concat(prefixCls, "-wrapper-input"));
    const wrapperCls = cls("".concat(prefixCls, "-wrapper"));
    return /*#__PURE__*/React.createElement("div", {
      style: style,
      className: tagInputCls,
      onMouseEnter: e => {
        this.handleInputMouseEnter(e);
      },
      onMouseLeave: e => {
        this.handleInputMouseLeave(e);
      }
    }, this.renderPrefix(), /*#__PURE__*/React.createElement("div", {
      className: wrapperCls
    }, this.renderTags(), /*#__PURE__*/React.createElement(Input, {
      ref: this.inputRef,
      className: inputCls,
      disabled: disabled,
      value: inputValue,
      size: size,
      placeholder: tagsArray.length === 0 ? placeholder : '',
      onKeyDown: e => {
        this.handleKeyDown(e);
      },
      onChange: (v, e) => {
        this.handleInputChange(e);
      },
      onBlur: e => {
        this.handleInputBlur(e);
      },
      onFocus: e => {
        this.handleInputFocus(e);
      }
    })), this.renderClearBtn(), this.renderSuffix());
  }

}

TagInput.propTypes = {
  children: PropTypes.node,
  style: PropTypes.object,
  className: PropTypes.string,
  disabled: PropTypes.bool,
  allowDuplicates: PropTypes.bool,
  max: PropTypes.number,
  maxTagCount: PropTypes.number,
  maxLength: PropTypes.number,
  showRestTagsPopover: PropTypes.bool,
  restTagsPopoverProps: PropTypes.object,
  showContentTooltip: PropTypes.bool,
  defaultValue: PropTypes.array,
  value: PropTypes.array,
  inputValue: PropTypes.string,
  placeholder: PropTypes.string,
  separator: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
  showClear: PropTypes.bool,
  addOnBlur: PropTypes.bool,
  autoFocus: PropTypes.bool,
  renderTagItem: PropTypes.func,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  onChange: PropTypes.func,
  onInputChange: PropTypes.func,
  onExceed: PropTypes.func,
  onInputExceed: PropTypes.func,
  onAdd: PropTypes.func,
  onRemove: PropTypes.func,
  onKeyDown: PropTypes.func,
  size: PropTypes.oneOf(strings.SIZE_SET),
  validateStatus: PropTypes.oneOf(strings.STATUS),
  prefix: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  suffix: PropTypes.oneOfType([PropTypes.string, PropTypes.node])
};
TagInput.defaultProps = {
  showClear: false,
  addOnBlur: false,
  allowDuplicates: true,
  showRestTagsPopover: true,
  autoFocus: false,
  showContentTooltip: true,
  separator: ',',
  size: 'default',
  validateStatus: 'default',
  onBlur: _noop,
  onFocus: _noop,
  onChange: _noop,
  onInputChange: _noop,
  onExceed: _noop,
  onInputExceed: _noop,
  onAdd: _noop,
  onRemove: _noop,
  onKeyDown: _noop
};
export default TagInput;