import _isNumber from "lodash/isNumber";
import _get from "lodash/get";
import _noop from "lodash/noop";
import _isString from "lodash/isString";
import _isEqual from "lodash/isEqual";
import _Map from "@babel/runtime-corejs3/core-js-stable/map";
import _sliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/slice";
import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _someInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/some";
import _Array$from from "@babel/runtime-corejs3/core-js-stable/array/from";
import _valuesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/values";

/* eslint-disable max-len */

/* eslint-disable max-lines-per-function */
import React, { Fragment } from 'react';
import ReactDOM from 'react-dom';
import cls from 'classnames';
import PropTypes from 'prop-types';
import ConfigContext from '../configProvider/context';
import SelectFoundation from '@douyinfe/semi-foundation/lib/es/select/foundation';
import { cssClasses, strings, numbers } from '@douyinfe/semi-foundation/lib/es/select/constants';
import BaseComponent from '../_base/baseComponent';
import Tag from '../tag/index';
import TagGroup from '../tag/group';
import LocaleConsumer from '../locale/localeConsumer';
import Popover from '../popover/index';
import { numbers as popoverNumbers } from '@douyinfe/semi-foundation/lib/es/popover/constants';
import { FixedSizeList as List } from 'react-window';
import { getOptionsFromGroup } from './utils';
import VirtualRow from './virtualRow';
import Input from '../input/index';
import Option from './option';
import OptionGroup from './optionGroup';
import Spin from '../spin';
import Trigger from '../trigger';
import { IconChevronDown, IconClear } from '@douyinfe/semi-icons';
import { isSemiIcon } from '../_utils';
import warning from '@douyinfe/semi-foundation/lib/es/utils/warning';
import '@douyinfe/semi-foundation/lib/es/select/select.css';
const prefixcls = cssClasses.PREFIX;
const key = 0; // Notes: Use the label of the option as the identifier, that is, the option in Select, the value is allowed to be the same, but the label must be unique

class Select extends BaseComponent {
  constructor(props) {
    var _context, _context2, _context3, _context4, _context5, _context6;

    super(props);

    this.handleInputChange = value => this.foundation.handleInputChange(value);

    this.state = {
      isOpen: false,
      isFocus: false,
      options: [],
      selections: new _Map(),
      dropdownMinWidth: null,
      optionKey: key,
      inputValue: '',
      showInput: false,
      focusIndex: props.defaultActiveFirstOption ? 0 : -1,
      keyboardEventSet: {},
      optionGroups: [],
      isHovering: false
    };
    /* Generate random string */

    this.selectOptionListID = _sliceInstanceProperty(_context = Math.random().toString(36)).call(_context, 2);
    this.virtualizeListRef = /*#__PURE__*/React.createRef();
    this.inputRef = /*#__PURE__*/React.createRef();
    this.triggerRef = /*#__PURE__*/React.createRef();
    this.optionsRef = /*#__PURE__*/React.createRef();
    this.clickOutsideHandler = null;
    this.onSelect = _bindInstanceProperty(_context2 = this.onSelect).call(_context2, this);
    this.onClear = _bindInstanceProperty(_context3 = this.onClear).call(_context3, this);
    this.onMouseEnter = _bindInstanceProperty(_context4 = this.onMouseEnter).call(_context4, this);
    this.onMouseLeave = _bindInstanceProperty(_context5 = this.onMouseLeave).call(_context5, this);
    this.renderOption = _bindInstanceProperty(_context6 = this.renderOption).call(_context6, this);
    this.foundation = new SelectFoundation(this.adapter);
    warning('optionLabelProp' in this.props, '[Semi Select] \'optionLabelProp\' has already been deprecated, please use \'renderSelectedItem\' instead.');
    warning('labelInValue' in this.props, '[Semi Select] \'labelInValue\' has already been deprecated, please use \'onChangeWithObject\' instead.');
  }

  get adapter() {
    var _this = this;

    const keyboardAdapter = {
      registerKeyDown: cb => {
        const keyboardEventSet = {
          onKeyDown: cb
        };
        this.setState({
          keyboardEventSet
        });
      },
      unregisterKeyDown: () => {
        this.setState({
          keyboardEventSet: {}
        });
      },
      updateFocusIndex: focusIndex => {
        this.setState({
          focusIndex
        });
      },
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      scrollToFocusOption: () => {}
    };
    const filterAdapter = {
      updateInputValue: value => {
        this.setState({
          inputValue: value
        });
      },
      toggleInputShow: (showInput, cb) => {
        this.setState({
          showInput
        }, () => {
          cb();
        });
      },
      focusInput: () => {
        if (this.inputRef && this.inputRef.current) {
          this.inputRef.current.focus();
        }
      }
    };
    const multipleAdapter = {
      notifyMaxLimit: option => this.props.onExceed(option),
      getMaxLimit: () => this.props.max,
      registerClickOutsideHandler: cb => {
        const clickOutsideHandler = e => {
          const optionInstance = this.optionsRef && this.optionsRef.current;
          const triggerDom = this.triggerRef && this.triggerRef.current; // eslint-disable-next-line react/no-find-dom-node

          const optionsDom = ReactDOM.findDOMNode(optionInstance); // let isInPanel = optionsDom && optionsDom.contains(e.target);
          // let isInTrigger = triggerDom && triggerDom.contains(e.target);

          if (optionsDom && !optionsDom.contains(e.target) && triggerDom && !triggerDom.contains(e.target)) {
            cb(e);
          }
        };

        this.clickOutsideHandler = clickOutsideHandler;
        document.addEventListener('mousedown', clickOutsideHandler, false);
      },
      unregisterClickOutsideHandler: () => {
        if (this.clickOutsideHandler) {
          document.removeEventListener('mousedown', this.clickOutsideHandler, false);
          this.clickOutsideHandler = null;
        }
      },
      rePositionDropdown: () => {
        let {
          optionKey
        } = this.state;
        optionKey = optionKey + 1;
        this.setState({
          optionKey
        });
      },
      notifyDeselect: (value, option) => {
        delete option._parentGroup;
        this.props.onDeselect(value, option);
      }
    };
    return _Object$assign(_Object$assign(_Object$assign(_Object$assign(_Object$assign({}, super.adapter), keyboardAdapter), filterAdapter), multipleAdapter), {
      // Collect all subitems, each item is visible by default when collected, and is not selected
      getOptionsFromChildren: function () {
        let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props.children;
        let optionGroups = [];
        let options = [];
        const {
          optionList
        } = _this.props;

        if (optionList && optionList.length) {
          options = _mapInstanceProperty(optionList).call(optionList, (itemOpt, index) => _Object$assign({
            _show: true,
            _selected: false,
            _scrollIndex: index
          }, itemOpt));
          optionGroups[0] = {
            children: options,
            label: ''
          };
        } else {
          const result = getOptionsFromGroup(children);
          optionGroups = result.optionGroups;
          options = result.options;
        }

        _this.setState({
          optionGroups
        });

        return options;
      },
      updateOptions: options => {
        this.setState({
          options
        });
      },
      openMenu: () => {
        this.setState({
          isOpen: true
        });
      },
      closeMenu: () => {
        this.setState({
          isOpen: false
        });
      },
      getTriggerWidth: () => {
        const el = this.triggerRef.current;
        return el && el.getBoundingClientRect().width;
      },
      setOptionWrapperWidth: width => {
        this.setState({
          dropdownMinWidth: width
        });
      },
      updateSelection: selections => {
        this.setState({
          selections
        });
      },
      // clone Map, important!!!, prevent unexpected modify on state
      getSelections: () => new _Map(this.state.selections),
      notifyChange: value => {
        this.props.onChange(value);
      },
      notifySelect: (value, option) => {
        delete option._parentGroup;
        this.props.onSelect(value, option);
      },
      notifyDropdownVisibleChange: visible => {
        this.props.onDropdownVisibleChange(visible);
      },
      notifySearch: input => {
        this.props.onSearch(input);
      },
      notifyCreate: input => {
        this.props.onCreate(input);
      },
      notifyMouseEnter: e => {
        this.props.onMouseEnter(e);
      },
      notifyMouseLeave: e => {
        this.props.onMouseLeave(e);
      },
      notifyFocus: event => {
        this.props.onFocus(event);
      },
      notifyBlur: event => {
        this.props.onBlur(event);
      },
      notifyClear: () => {
        this.props.onClear();
      },
      notifyListScroll: e => {
        this.props.onListScroll(e);
      },
      updateHovering: isHovering => {
        this.setState({
          isHovering
        });
      },
      updateFocusState: isFocus => {
        this.setState({
          isFocus
        });
      },
      focusTrigger: () => {
        try {
          const el = this.triggerRef.current;
          el.focus();
        } catch (error) {}
      },
      updateScrollTop: () => {
        var _context7, _context8;

        // eslint-disable-next-line max-len
        let destNode = document.querySelector(_concatInstanceProperty(_context7 = _concatInstanceProperty(_context8 = "#".concat(prefixcls, "-")).call(_context8, this.selectOptionListID, " .")).call(_context7, prefixcls, "-option-selected"));

        if (_Array$isArray(destNode)) {
          // eslint-disable-next-line prefer-destructuring
          destNode = destNode[0];
        }

        if (destNode) {
          /**
           * Scroll the first selected item into view.
           * The reason why ScrollIntoView is not used here is that it may cause page to move.
           */
          const destParent = destNode.parentNode;
          destParent.scrollTop = destNode.offsetTop - destParent.offsetTop - destParent.clientHeight / 2 + destNode.clientHeight / 2;
        }
      }
    });
  }

  componentDidMount() {
    this.foundation.init();
  }

  componentWillUnmount() {
    this.foundation.destroy();
  }

  componentDidUpdate(prevProps, prevState) {
    var _context9, _context10;

    const prevChildrenKeys = _mapInstanceProperty(_context9 = React.Children.toArray(prevProps.children)).call(_context9, child => child.key);

    const nowChildrenKeys = _mapInstanceProperty(_context10 = React.Children.toArray(this.props.children)).call(_context10, child => child.key);

    let isOptionsChanged = false;

    if (!_isEqual(prevChildrenKeys, nowChildrenKeys) || !_isEqual(prevProps.optionList, this.props.optionList)) {
      isOptionsChanged = true;
      this.foundation.handleOptionListChange();
    } // Add isOptionChanged: There may be cases where the value is unchanged, but the optionList is updated. At this time, the label corresponding to the value may change, and the selected item needs to be updated


    if (prevProps.value !== this.props.value || isOptionsChanged) {
      if ('value' in this.props) {
        this.foundation.handleValueChange(this.props.value);
      } else {
        this.foundation.handleOptionListChangeHadDefaultValue();
      }
    }
  }

  renderInput() {
    const {
      size,
      multiple,
      disabled,
      inputProps
    } = this.props;

    const inputPropsCls = _get(inputProps, 'className');

    const inputcls = cls("".concat(prefixcls, "-input"), {
      ["".concat(prefixcls, "-input-single")]: !multiple,
      ["".concat(prefixcls, "-input-multiple")]: multiple
    }, inputPropsCls);
    const {
      inputValue
    } = this.state;

    const selectInputProps = _Object$assign({
      value: inputValue,
      disabled,
      className: inputcls,
      onChange: this.handleInputChange
    }, inputProps);

    let style = {}; // Multiple choice mode

    if (multiple) {
      style = {
        width: inputValue ? "".concat(inputValue.length * 16, "px") : '2px'
      };
      selectInputProps.style = style;
    }

    return /*#__PURE__*/React.createElement(Input, _Object$assign({
      ref: this.inputRef,
      size: size,
      onFocus: e => {
        // prevent event bubbling which will fire trigger onFocus event
        e.stopPropagation(); // e.nativeEvent.stopImmediatePropagation();
      }
    }, selectInputProps));
  }

  close() {
    this.foundation.close();
  }

  open() {
    this.foundation.open();
  }

  clearInput() {
    this.foundation.clearInput();
  }

  selectAll() {
    this.foundation.selectAll();
  }

  deselectAll() {
    this.foundation.clearSelected();
  }

  focus() {
    this.foundation.focus();
  }

  onSelect(option, optionIndex, e) {
    this.foundation.onSelect(option, optionIndex, e);
  }

  onClear(e) {
    e.nativeEvent.stopImmediatePropagation();
    this.foundation.handleClearClick(e);
  }

  renderEmpty() {
    return /*#__PURE__*/React.createElement(Option, {
      empty: true,
      emptyContent: this.props.emptyContent
    });
  }

  renderLoading() {
    const loadingWrapperCls = "".concat(prefixcls, "-loading-wrapper");
    return /*#__PURE__*/React.createElement("div", {
      className: loadingWrapperCls
    }, /*#__PURE__*/React.createElement(Spin, null));
  }

  renderOption(option, optionIndex, style) {
    const {
      focusIndex,
      inputValue
    } = this.state;
    const {
      renderOptionItem
    } = this.props;
    let optionContent;
    const isFocused = optionIndex === focusIndex;
    let optionStyle = style || {};

    if (option.style) {
      optionStyle = _Object$assign(_Object$assign({}, optionStyle), option.style);
    }

    if (option._inputCreateOnly) {
      optionContent = this.renderCreateOption(option, isFocused, optionIndex, style);
    } else {
      // use another name to make sure that 'key' in optionList still exist when we call onChange
      if ('key' in option) {
        option._keyInOptionList = option.key;
      }

      optionContent = /*#__PURE__*/React.createElement(Option, _Object$assign({
        showTick: true
      }, option, {
        selected: option._selected,
        onSelect: (v, e) => this.onSelect(v, optionIndex, e),
        focused: isFocused,
        onMouseEnter: () => this.onOptionHover(optionIndex),
        style: optionStyle,
        key: option.key || option.label + option.value + optionIndex,
        renderOptionItem: renderOptionItem,
        inputValue: inputValue
      }), option.label);
    }

    return optionContent;
  }

  renderCreateOption(option, isFocused, optionIndex, style) {
    const {
      renderCreateItem
    } = this.props; // default render method

    if (typeof renderCreateItem === 'undefined') {
      const defaultCreateItem = /*#__PURE__*/React.createElement(Option, _Object$assign({
        key: option.key || option.label + option.value,
        onSelect: (v, e) => this.onSelect(v, optionIndex, e),
        onMouseEnter: () => this.onOptionHover(optionIndex),
        showTick: true
      }, option, {
        focused: isFocused,
        style: style
      }), /*#__PURE__*/React.createElement(LocaleConsumer, {
        componentName: "Select"
      }, locale => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
        className: "".concat(prefixcls, "-create-tips")
      }, locale.createText), option.value)));
      return defaultCreateItem;
    }

    const customCreateItem = renderCreateItem(option.value, isFocused);
    return /*#__PURE__*/React.createElement("div", {
      onClick: e => this.onSelect(option, optionIndex, e),
      key: new Date().valueOf()
    }, customCreateItem);
  }

  onOptionHover(optionIndex) {
    this.foundation.handleOptionMouseEnter(optionIndex);
  }

  renderWithGroup(visibileOptions) {
    const content = [];
    const groupStatus = new _Map();

    _forEachInstanceProperty(visibileOptions).call(visibileOptions, (option, optionIndex) => {
      const parentGroup = option._parentGroup;
      const optionContent = this.renderOption(option, optionIndex);

      if (parentGroup && groupStatus.has(parentGroup.label)) {
        // group content already insert
        content.push(optionContent);
      } else if (parentGroup) {
        const groupContent = /*#__PURE__*/React.createElement(OptionGroup, _Object$assign({}, parentGroup, {
          key: parentGroup.label
        }));
        groupStatus.set(parentGroup.label, true);
        content.push(groupContent);
        content.push(optionContent);
      } else {
        // when not use with OptionGroup
        content.push(optionContent);
      }
    });

    return content;
  }

  renderVirtualizeList(visibileOptions) {
    const {
      virtualize
    } = this.props;
    const {
      direction
    } = this.context;
    const {
      height,
      width,
      itemSize
    } = virtualize;
    return /*#__PURE__*/React.createElement(List, {
      ref: this.virtualizeListRef,
      height: height || numbers.LIST_HEIGHT,
      itemCount: visibileOptions.length,
      itemSize: itemSize,
      itemData: {
        visibileOptions,
        renderOption: this.renderOption
      },
      width: width || '100%',
      style: {
        direction
      }
    }, VirtualRow);
  }

  renderOptions(children) {
    var _context11;

    const {
      dropdownMinWidth,
      options,
      selections
    } = this.state;
    const {
      maxHeight,
      dropdownClassName,
      dropdownStyle,
      outerTopSlot,
      innerTopSlot,
      outerBottomSlot,
      innerBottomSlot,
      loading,
      virtualize
    } = this.props; // Do a filter first, instead of directly judging in forEach, so that the focusIndex can correspond to

    const visibileOptions = _filterInstanceProperty(options).call(options, item => item._show);

    let listContent = this.renderWithGroup(visibileOptions);

    if (virtualize) {
      listContent = this.renderVirtualizeList(visibileOptions);
    }

    const style = _Object$assign({
      minWidth: dropdownMinWidth
    }, dropdownStyle);

    const optionListCls = cls({
      ["".concat(prefixcls, "-option-list")]: true,
      ["".concat(prefixcls, "-option-list-chosen")]: selections.size
    });
    const isEmpty = !options.length || !_someInstanceProperty(options).call(options, item => item._show);
    return /*#__PURE__*/React.createElement("div", {
      id: _concatInstanceProperty(_context11 = "".concat(prefixcls, "-")).call(_context11, this.selectOptionListID),
      className: dropdownClassName,
      style: style
    }, outerTopSlot, /*#__PURE__*/React.createElement("div", {
      style: {
        maxHeight: "".concat(maxHeight, "px")
      },
      className: optionListCls,
      role: "listbox",
      onScroll: e => this.foundation.handleListScroll(e)
    }, innerTopSlot, !loading ? listContent : this.renderLoading(), isEmpty && !loading ? this.renderEmpty() : null, innerBottomSlot), outerBottomSlot);
  }

  renderSingleSelection(selections, filterable) {
    let {
      renderSelectedItem
    } = this.props;
    const {
      placeholder
    } = this.props;
    const {
      showInput,
      inputValue
    } = this.state;
    let renderText = '';
    const selectedItems = [...selections];

    if (typeof renderSelectedItem === 'undefined') {
      renderSelectedItem = optionNode => optionNode.label;
    }

    if (selectedItems.length) {
      const selectedItem = selectedItems[0][1];
      renderText = renderSelectedItem(selectedItem);
    }

    const spanCls = cls({
      ["".concat(prefixcls, "-selection-text")]: true,
      ["".concat(prefixcls, "-selection-placeholder")]: !renderText && renderText !== 0,
      ["".concat(prefixcls, "-selection-text-hide")]: inputValue && showInput,
      ["".concat(prefixcls, "-selection-text-inactive")]: !inputValue && showInput // Stack Input & RenderText(opacity 0.4)

    });
    const contentWrapperCls = "".concat(prefixcls, "-content-wrapper");
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
      className: contentWrapperCls
    }, /*#__PURE__*/React.createElement("span", {
      className: spanCls
    }, renderText || renderText === 0 ? renderText : placeholder), filterable && showInput ? this.renderInput() : null));
  }

  renderMultipleSelection(selections, filterable) {
    let {
      renderSelectedItem
    } = this.props;
    const {
      placeholder,
      maxTagCount,
      size
    } = this.props;
    const {
      inputValue
    } = this.state;
    const selectDisabled = this.props.disabled;
    const renderTags = [];
    const selectedItems = [...selections];

    if (typeof renderSelectedItem === 'undefined') {
      renderSelectedItem = optionNode => ({
        isRenderInTag: true,
        content: optionNode.label
      });
    }

    const tags = _mapInstanceProperty(selectedItems).call(selectedItems, (item, i) => {
      const label = item[0];
      const {
        value
      } = item[1];
      const disabled = item[1].disabled || selectDisabled;

      const onClose = (tagContent, e) => {
        if (e && typeof e.preventDefault === 'function') {
          e.preventDefault(); // make sure that tag will not hidden immediately in controlled mode
        }

        this.foundation.removeTag({
          label,
          value
        });
      };

      const {
        content,
        isRenderInTag
      } = renderSelectedItem(item[1], {
        index: i,
        disabled,
        onClose
      });
      const basic = {
        disabled,
        closable: !disabled,
        onClose
      };

      if (isRenderInTag) {
        return /*#__PURE__*/React.createElement(Tag, _Object$assign({}, basic, {
          color: "white",
          size: size || 'large',
          key: value
        }), content);
      } else {
        return /*#__PURE__*/React.createElement(Fragment, {
          key: value
        }, content);
      }
    });

    const contentWrapperCls = cls({
      ["".concat(prefixcls, "-content-wrapper")]: true,
      ["".concat(prefixcls, "-content-wrapper-one-line")]: maxTagCount,
      ["".concat(prefixcls, "-content-wrapper-empty")]: !tags.length
    });
    const spanCls = cls({
      ["".concat(prefixcls, "-selection-text")]: true,
      ["".concat(prefixcls, "-selection-placeholder")]: !tags.length,
      ["".concat(prefixcls, "-selection-text-hide")]: tags && tags.length // [prefixcls + '-selection-text-inactive']: !inputValue && !tags.length,

    });
    const placeholderText = placeholder && !inputValue ? /*#__PURE__*/React.createElement("span", {
      className: spanCls
    }, placeholder) : null;
    const n = tags.length > maxTagCount ? maxTagCount : undefined;
    const NotOneLine = !maxTagCount; // Multiple lines (that is, do not set maxTagCount), do not use TagGroup, directly traverse with Tag, otherwise Input cannot follow the correct position

    const tagContent = NotOneLine ? tags : /*#__PURE__*/React.createElement(TagGroup, {
      tagList: tags,
      maxTagCount: n,
      size: "large",
      mode: "custom"
    });
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
      className: contentWrapperCls
    }, tags && tags.length ? tagContent : placeholderText, !filterable ? null : this.renderInput()));
  }

  onMouseEnter(e) {
    this.foundation.handleMouseEnter(e);
  }

  onMouseLeave(e) {
    this.foundation.handleMouseLeave(e);
  }
  /* Processing logic when popover visible changes */


  handlePopoverVisibleChange(status) {
    const {
      virtualize
    } = this.props;
    const {
      selections
    } = this.state;

    if (!status) {
      return;
    }

    if (virtualize) {
      let minItemIndex = -1;

      _forEachInstanceProperty(selections).call(selections, item => {
        const itemIndex = _get(item, '_scrollIndex');
        /* When the itemIndex is legal */


        if (_isNumber(itemIndex) && itemIndex >= 0) {
          minItemIndex = minItemIndex !== -1 && minItemIndex < itemIndex ? minItemIndex : itemIndex;
        }
      });

      if (minItemIndex !== -1) {
        try {
          this.virtualizeListRef.current.scrollToItem(minItemIndex, 'center');
        } catch (error) {}
      }
    } else {
      this.foundation.updateScrollTop();
    }
  }

  renderSuffix() {
    const {
      suffix
    } = this.props;
    const suffixWrapperCls = cls({
      ["".concat(prefixcls, "-suffix")]: true,
      ["".concat(prefixcls, "-suffix-text")]: suffix && _isString(suffix),
      ["".concat(prefixcls, "-suffix-icon")]: isSemiIcon(suffix)
    });
    return /*#__PURE__*/React.createElement("div", {
      className: suffixWrapperCls
    }, suffix);
  }

  renderPrefix() {
    const {
      prefix,
      insetLabel
    } = this.props;
    const labelNode = prefix || insetLabel;
    const prefixWrapperCls = cls({
      ["".concat(prefixcls, "-prefix")]: true,
      ["".concat(prefixcls, "-inset-label")]: insetLabel,
      ["".concat(prefixcls, "-prefix-text")]: labelNode && _isString(labelNode),
      ["".concat(prefixcls, "-prefix-icon")]: isSemiIcon(labelNode)
    });
    return /*#__PURE__*/React.createElement("div", {
      className: prefixWrapperCls
    }, labelNode);
  }

  renderSelection() {
    const {
      disabled,
      multiple,
      filter,
      style,
      id,
      size,
      className,
      validateStatus,
      showArrow,
      suffix,
      prefix,
      insetLabel,
      placeholder,
      triggerRender,
      arrowIcon
    } = this.props;
    const {
      selections,
      isOpen,
      keyboardEventSet,
      inputValue,
      isHovering,
      isFocus
    } = this.state;
    const useCustomTrigger = typeof triggerRender === 'function';
    const filterable = Boolean(filter); // filter（boolean || function）

    const selectionCls = useCustomTrigger ? cls(className) : cls(prefixcls, className, {
      ["".concat(prefixcls, "-open")]: isOpen,
      ["".concat(prefixcls, "-focus")]: isFocus,
      ["".concat(prefixcls, "-disabled")]: disabled,
      ["".concat(prefixcls, "-single")]: !multiple,
      ["".concat(prefixcls, "-multiple")]: multiple,
      ["".concat(prefixcls, "-filterable")]: filterable,
      ["".concat(prefixcls, "-small")]: size === 'small',
      ["".concat(prefixcls, "-large")]: size === 'large',
      ["".concat(prefixcls, "-error")]: validateStatus === 'error',
      ["".concat(prefixcls, "-warning")]: validateStatus === 'warning',
      ["".concat(prefixcls, "-no-arrow")]: !showArrow,
      ["".concat(prefixcls, "-with-prefix")]: prefix || insetLabel,
      ["".concat(prefixcls, "-with-suffix")]: suffix
    });
    const showClear = this.props.showClear && (selections.size || inputValue) && !disabled && (isHovering || isOpen);
    const arrowContent = showArrow ? /*#__PURE__*/React.createElement("div", {
      className: "".concat(prefixcls, "-arrow")
    }, arrowIcon) : /*#__PURE__*/React.createElement("div", {
      className: "".concat(prefixcls, "-arrow-empty")
    });
    const inner = useCustomTrigger ? /*#__PURE__*/React.createElement(Trigger, {
      value: _Array$from(_valuesInstanceProperty(selections).call(selections)),
      inputValue: inputValue,
      onChange: this.handleInputChange,
      onClear: this.onClear,
      disabled: disabled,
      triggerRender: triggerRender,
      placeholder: placeholder,
      componentName: "Select",
      componentProps: _Object$assign({}, this.props)
    }) : [/*#__PURE__*/React.createElement(Fragment, {
      key: "prefix"
    }, prefix || insetLabel ? this.renderPrefix() : null), /*#__PURE__*/React.createElement(Fragment, {
      key: "selection"
    }, /*#__PURE__*/React.createElement("div", {
      className: cls("".concat(prefixcls, "-selection"))
    }, multiple ? this.renderMultipleSelection(selections, filterable) : this.renderSingleSelection(selections, filterable))), /*#__PURE__*/React.createElement(Fragment, {
      key: "clearicon"
    }, showClear ? /*#__PURE__*/React.createElement("div", {
      className: cls("".concat(prefixcls, "-clear")),
      onClick: this.onClear
    }, /*#__PURE__*/React.createElement(IconClear, null)) : arrowContent), /*#__PURE__*/React.createElement(Fragment, {
      key: "suffix"
    }, suffix ? this.renderSuffix() : null)];
    const tabIndex = disabled ? null : 0;
    return /*#__PURE__*/React.createElement("div", _Object$assign({
      className: selectionCls,
      ref: ref => this.triggerRef.current = ref,
      onClick: e => this.foundation.handleClick(e),
      style: style,
      id: id,
      tabIndex: tabIndex,
      onMouseEnter: this.onMouseEnter,
      onMouseLeave: this.onMouseLeave,
      // onFocus={e => this.foundation.handleTriggerFocus(e)}
      onBlur: e => this.foundation.handleTriggerBlur(e)
    }, keyboardEventSet), inner);
  }

  render() {
    const {
      direction
    } = this.context;
    const defaultPosition = direction === 'rtl' ? 'bottomRight' : 'bottomLeft';
    const {
      children,
      position = defaultPosition,
      zIndex,
      getPopupContainer,
      motion,
      autoAdjustOverflow,
      mouseLeaveDelay,
      mouseEnterDelay,
      spacing,
      stopPropagation
    } = this.props;
    const {
      isOpen,
      optionKey
    } = this.state;
    const optionList = this.renderOptions(children);
    const selection = this.renderSelection();
    return /*#__PURE__*/React.createElement(Popover, {
      getPopupContainer: getPopupContainer,
      motion: motion,
      autoAdjustOverflow: autoAdjustOverflow,
      mouseLeaveDelay: mouseLeaveDelay,
      mouseEnterDelay: mouseEnterDelay,
      // transformFromCenter TODO: check no such property
      zIndex: zIndex,
      ref: this.optionsRef,
      content: optionList,
      visible: isOpen,
      trigger: "custom",
      rePosKey: optionKey,
      position: position,
      spacing: spacing,
      stopPropagation: stopPropagation,
      onVisibleChange: status => this.handlePopoverVisibleChange(status)
    }, selection);
  }

}

Select.contextType = ConfigContext;
Select.Option = Option;
Select.OptGroup = OptionGroup;
Select.propTypes = {
  autoFocus: PropTypes.bool,
  children: PropTypes.node,
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array, PropTypes.object]),
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array, PropTypes.object]),
  placeholder: PropTypes.node,
  onChange: PropTypes.func,
  multiple: PropTypes.bool,
  // Whether to turn on the input box filtering function, when it is a function, it represents a custom filtering function
  filter: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  // How many tags can you choose?
  max: PropTypes.number,
  // How many tabs are displayed at most, and the rest are displayed in + N
  maxTagCount: PropTypes.number,
  maxHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  style: PropTypes.object,
  className: PropTypes.string,
  size: PropTypes.oneOf(strings.SIZE_SET),
  disabled: PropTypes.bool,
  emptyContent: PropTypes.node,
  onDropdownVisibleChange: PropTypes.func,
  zIndex: PropTypes.number,
  position: PropTypes.oneOf(strings.POSITION_SET),
  onSearch: PropTypes.func,
  getPopupContainer: PropTypes.func,
  dropdownClassName: PropTypes.string,
  dropdownStyle: PropTypes.object,
  outerTopSlot: PropTypes.node,
  innerTopSlot: PropTypes.node,
  inputProps: PropTypes.object,
  outerBottomSlot: PropTypes.node,
  innerBottomSlot: PropTypes.node,
  optionList: PropTypes.array,
  dropdownMatchSelectWidth: PropTypes.bool,
  loading: PropTypes.bool,
  defaultOpen: PropTypes.bool,
  validateStatus: PropTypes.oneOf(strings.STATUS),
  defaultActiveFirstOption: PropTypes.bool,
  triggerRender: PropTypes.func,
  stopPropagation: PropTypes.bool,
  // motion doesn't need to be exposed
  motion: PropTypes.oneOfType([PropTypes.func, PropTypes.bool, PropTypes.object]),
  onChangeWithObject: PropTypes.bool,
  suffix: PropTypes.node,
  prefix: PropTypes.node,
  insetLabel: PropTypes.node,
  showClear: PropTypes.bool,
  showArrow: PropTypes.bool,
  renderSelectedItem: PropTypes.func,
  allowCreate: PropTypes.bool,
  renderCreateItem: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  clickToHide: PropTypes.bool,
  onExceed: PropTypes.func,
  onCreate: PropTypes.func,
  remote: PropTypes.bool,
  onDeselect: PropTypes.func,
  // The main difference between onSelect and onChange is that when multiple selections are selected, onChange contains all options, while onSelect only contains items for the current operation
  onSelect: PropTypes.func,
  autoAdjustOverflow: PropTypes.bool,
  mouseEnterDelay: PropTypes.number,
  mouseLeaveDelay: PropTypes.number,
  spacing: PropTypes.number,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  onClear: PropTypes.func,
  virtualize: PropTypes.object,
  renderOptionItem: PropTypes.func,
  onListScroll: PropTypes.func,
  arrowIcon: PropTypes.node // open: PropTypes.bool,
  // tagClosable: PropTypes.bool,

};
Select.defaultProps = {
  stopPropagation: true,
  motion: true,
  zIndex: popoverNumbers.DEFAULT_Z_INDEX,
  // position: 'bottomLeft',
  filter: false,
  multiple: false,
  disabled: false,
  defaultOpen: false,
  allowCreate: false,
  placeholder: '',
  onDropdownVisibleChange: _noop,
  onChangeWithObject: false,
  onChange: _noop,
  onSearch: _noop,
  onMouseEnter: _noop,
  onMouseLeave: _noop,
  onDeselect: _noop,
  onSelect: _noop,
  onCreate: _noop,
  onExceed: _noop,
  onFocus: _noop,
  onBlur: _noop,
  onClear: _noop,
  onListScroll: _noop,
  maxHeight: 300,
  dropdownMatchSelectWidth: true,
  defaultActiveFirstOption: false,
  showArrow: true,
  showClear: false,
  remote: false,
  autoAdjustOverflow: true,
  arrowIcon: /*#__PURE__*/React.createElement(IconChevronDown, null) // Radio selection is different from the default renderSelectedItem for multiple selection, so it is not declared here
  // renderSelectedItem: (optionNode) => optionNode.label,
  // The default creator rendering is related to i18, so it is not declared here
  // renderCreateItem: (input) => input

};
export default Select;