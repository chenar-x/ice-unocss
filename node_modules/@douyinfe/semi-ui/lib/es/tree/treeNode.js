import _isString from "lodash/isString";
import _isFunction from "lodash/isFunction";
import _debounce from "lodash/debounce";
import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && _indexOfInstanceProperty(e).call(e, p) < 0) t[p] = s[p];

  if (s != null && typeof _Object$getOwnPropertySymbols === "function") for (var i = 0, p = _Object$getOwnPropertySymbols(s); i < p.length; i++) {
    if (_indexOfInstanceProperty(e).call(e, p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

import React, { PureComponent } from 'react';
import cls from 'classnames';
import PropTypes from 'prop-types';
import { cssClasses } from '@douyinfe/semi-foundation/lib/es/tree/constants';
import { IconTreeTriangleDown, IconFile, IconFolder, IconFolderOpen } from '@douyinfe/semi-icons';
import { Checkbox } from '../checkbox';
import TreeContext from './treeContext';
import Spin from '../spin';
const prefixcls = cssClasses.PREFIX_OPTION;
export default class TreeNode extends PureComponent {
  constructor(props) {
    super(props);

    this.onSelect = e => {
      const {
        onNodeSelect
      } = this.context;
      onNodeSelect(e, this.props);
    };

    this.onExpand = e => {
      const {
        onNodeExpand
      } = this.context;
      e && e.stopPropagation();
      e.nativeEvent.stopImmediatePropagation();
      onNodeExpand(e, this.props);
    };

    this.onCheck = e => {
      if (this.isDisabled()) {
        return;
      }

      const {
        onNodeCheck
      } = this.context;
      e.stopPropagation();
      e.nativeEvent.stopImmediatePropagation();
      onNodeCheck(e, this.props);
    };

    this.onContextMenu = e => {
      const {
        onNodeRightClick
      } = this.context;
      onNodeRightClick(e, this.props);
    };

    this.onClick = e => {
      const {
        expandAction
      } = this.context;

      if (expandAction === 'doubleClick') {
        this.debounceSelect(e);
        return;
      }

      this.onSelect(e);

      if (expandAction === 'click') {
        this.onExpand(e);
      }
    };

    this.onDoubleClick = e => {
      const {
        expandAction,
        onNodeDoubleClick
      } = this.context;
      e.stopPropagation();
      e.nativeEvent.stopImmediatePropagation();

      if (_isFunction(onNodeDoubleClick)) {
        onNodeDoubleClick(e, this.props);
      }

      if (expandAction === 'doubleClick') {
        this.onExpand(e);
      }
    };

    this.onDragStart = e => {
      const {
        onNodeDragStart
      } = this.context;
      e.stopPropagation();
      onNodeDragStart(e, _Object$assign(_Object$assign({}, this.props), {
        nodeInstance: this.refNode
      }));

      try {
        // ie throw error
        // firefox-need-it
        e.dataTransfer.setData('text/plain', '');
      } catch (error) {// empty
      }
    };

    this.onDragEnter = e => {
      const {
        onNodeDragEnter
      } = this.context;
      e.preventDefault();
      e.stopPropagation();
      onNodeDragEnter(e, _Object$assign(_Object$assign({}, this.props), {
        nodeInstance: this.refNode
      }));
    };

    this.onDragOver = e => {
      const {
        onNodeDragOver
      } = this.context;
      e.preventDefault();
      e.stopPropagation();
      onNodeDragOver(e, _Object$assign(_Object$assign({}, this.props), {
        nodeInstance: this.refNode
      }));
    };

    this.onDragLeave = e => {
      const {
        onNodeDragLeave
      } = this.context;
      e.stopPropagation();
      onNodeDragLeave(e, _Object$assign(_Object$assign({}, this.props), {
        nodeInstance: this.refNode
      }));
    };

    this.onDragEnd = e => {
      const {
        onNodeDragEnd
      } = this.context;
      e.stopPropagation();
      onNodeDragEnd(e, _Object$assign(_Object$assign({}, this.props), {
        nodeInstance: this.refNode
      }));
    };

    this.onDrop = e => {
      const {
        onNodeDrop
      } = this.context;
      e.preventDefault();
      e.stopPropagation();
      onNodeDrop(e, _Object$assign(_Object$assign({}, this.props), {
        nodeInstance: this.refNode
      }));
    };

    this.getNodeChildren = () => {
      const {
        children
      } = this.props;
      return children || [];
    };

    this.isLeaf = () => {
      const {
        isLeaf,
        loaded
      } = this.props;
      const {
        loadData
      } = this.context;
      const hasChildren = this.getNodeChildren().length !== 0;

      if (isLeaf === false) {
        return false;
      }

      return isLeaf || !loadData && !hasChildren || loadData && loaded && !hasChildren;
    };

    this.isDisabled = () => {
      const {
        disabled
      } = this.props;
      const {
        treeDisabled
      } = this.context;

      if (disabled === false) {
        return false;
      }

      return Boolean(treeDisabled || disabled);
    };

    this.renderRealLabel = () => {
      const {
        renderLabel
      } = this.context;
      const {
        label,
        keyword,
        data,
        filtered,
        treeNodeFilterProp
      } = this.props;

      if (_isFunction(renderLabel)) {
        return renderLabel(label, data);
      } else if (_isString(label) && filtered && keyword && treeNodeFilterProp === 'label') {
        var _context;

        const content = [];

        _forEachInstanceProperty(_context = label.split(keyword)).call(_context, (node, index) => {
          if (index > 0) {
            content.push( /*#__PURE__*/React.createElement("span", {
              className: "".concat(prefixcls, "-highlight"),
              key: index
            }, keyword));
          }

          content.push(node);
        });

        return content;
      } else {
        return label;
      }
    };

    this.setRef = node => {
      this.refNode = node;
    };

    this.state = {};
    this.debounceSelect = _debounce(this.onSelect, 500, {
      leading: true,
      trailing: false
    });
  }

  renderArrow() {
    const showIcon = !this.isLeaf();
    const {
      loading
    } = this.props;

    if (loading) {
      return /*#__PURE__*/React.createElement(Spin, {
        wrapperClassName: "".concat(prefixcls, "-spin-icon")
      });
    }

    if (showIcon) {
      return /*#__PURE__*/React.createElement(IconTreeTriangleDown, {
        className: "".concat(prefixcls, "-expand-icon"),
        size: "small",
        onClick: this.onExpand
      });
    }

    return /*#__PURE__*/React.createElement("span", {
      className: "".concat(prefixcls, "-empty-icon")
    });
  }

  renderCheckbox() {
    const {
      checked,
      halfChecked
    } = this.props;
    const disabled = this.isDisabled();
    return /*#__PURE__*/React.createElement("div", {
      onClick: this.onCheck
    }, /*#__PURE__*/React.createElement(Checkbox, {
      indeterminate: halfChecked,
      checked: checked,
      disabled: Boolean(disabled)
    }));
  }

  renderIcon() {
    const {
      directory,
      treeIcon
    } = this.context;
    const {
      expanded,
      icon
    } = this.props;
    const hasChild = !this.isLeaf();
    const hasIcon = icon || treeIcon;
    let itemIcon;

    if (hasIcon || directory) {
      if (hasIcon) {
        itemIcon = icon || treeIcon;
      } else {
        if (!hasChild) {
          itemIcon = /*#__PURE__*/React.createElement(IconFile, {
            className: "".concat(prefixcls, "-item-icon")
          });
        } else {
          // eslint-disable-next-line max-len
          itemIcon = expanded ? /*#__PURE__*/React.createElement(IconFolderOpen, {
            className: "".concat(prefixcls, "-item-icon")
          }) : /*#__PURE__*/React.createElement(IconFolder, {
            className: "".concat(prefixcls, "-item-icon")
          });
        }
      }
    }

    return itemIcon;
  }

  renderEmptyNode() {
    var _context2;

    const {
      emptyContent
    } = this.props;
    const wrapperCls = cls(prefixcls, {
      ["".concat(prefixcls, "-empty")]: true
    });
    return /*#__PURE__*/React.createElement("ul", {
      className: wrapperCls
    }, /*#__PURE__*/React.createElement("span", {
      className: _concatInstanceProperty(_context2 = "".concat(prefixcls, "-label ")).call(_context2, prefixcls, "-label-empty")
    }, emptyContent));
  } // eslint-disable-next-line max-lines-per-function


  render() {
    var _context3;

    const _a = this.props,
          {
      eventKey,
      expanded,
      selected,
      checked,
      halfChecked,
      loading,
      active,
      level,
      empty,
      filtered,
      treeNodeFilterProp,
      // eslint-disable-next-line no-unused-vars
      display,
      style
    } = _a,
          rest = __rest(_a, ["eventKey", "expanded", "selected", "checked", "halfChecked", "loading", "active", "level", "empty", "filtered", "treeNodeFilterProp", "display", "style"]);

    if (empty) {
      return this.renderEmptyNode();
    }

    const {
      multiple,
      draggable,
      renderFullLabel,
      dragOverNodeKey,
      dropPosition,
      labelEllipsis
    } = this.context;
    const disabled = this.isDisabled();
    const dragOver = dragOverNodeKey === eventKey && dropPosition === 0;
    const dragOverGapTop = dragOverNodeKey === eventKey && dropPosition === -1;
    const dragOverGapBottom = dragOverNodeKey === eventKey && dropPosition === 1;
    const nodeCls = cls(prefixcls, {
      [_concatInstanceProperty(_context3 = "".concat(prefixcls, "-level-")).call(_context3, level + 1)]: true,
      ["".concat(prefixcls, "-collapsed")]: !expanded,
      ["".concat(prefixcls, "-disabled")]: Boolean(disabled),
      ["".concat(prefixcls, "-selected")]: selected,
      ["".concat(prefixcls, "-active")]: !multiple && active,
      ["".concat(prefixcls, "-ellipsis")]: labelEllipsis,
      ["".concat(prefixcls, "-filtered")]: filtered && treeNodeFilterProp !== 'label',
      ["".concat(prefixcls, "-drag-over")]: !disabled && dragOver,
      ["".concat(prefixcls, "-draggable")]: !disabled && draggable && !renderFullLabel,
      // When draggable + renderFullLabel is enabled, the default style
      ["".concat(prefixcls, "-fullLabel-draggable")]: !disabled && draggable && renderFullLabel,
      // When draggable + renderFullLabel is turned on, the style of dragover
      ["".concat(prefixcls, "-fullLabel-drag-over-gap-top")]: !disabled && dragOverGapTop && renderFullLabel,
      ["".concat(prefixcls, "-fullLabel-drag-over-gap-bottom")]: !disabled && dragOverGapBottom && renderFullLabel
    });
    const labelProps = {
      onClick: this.onClick,
      onContextMenu: this.onContextMenu,
      onDoubleClick: this.onDoubleClick,
      className: nodeCls,
      onExpand: this.onExpand,
      data: rest.data,
      level,
      onCheck: this.onCheck,
      style,
      expandIcon: this.renderArrow(),
      checkStatus: {
        checked,
        halfChecked
      },
      expandStatus: {
        expanded,
        loading
      }
    };
    const dragProps = {
      onDoubleClick: this.onDoubleClick,
      onDragStart: draggable ? this.onDragStart : undefined,
      onDragEnter: draggable ? this.onDragEnter : undefined,
      onDragOver: draggable ? this.onDragOver : undefined,
      onDragLeave: draggable ? this.onDragLeave : undefined,
      onDrop: draggable ? this.onDrop : undefined,
      onDragEnd: draggable ? this.onDragEnd : undefined,
      draggable: !disabled && draggable || undefined
    };

    if (renderFullLabel) {
      const customLabel = renderFullLabel(_Object$assign({}, labelProps));

      if (draggable) {
        return /*#__PURE__*/React.cloneElement(customLabel, _Object$assign({
          ref: this.setRef
        }, dragProps));
      } else {
        return customLabel;
      }
    }

    const labelCls = cls("".concat(prefixcls, "-label"), {
      ["".concat(prefixcls, "-drag-over-gap-top")]: !disabled && dragOverGapTop,
      ["".concat(prefixcls, "-drag-over-gap-bottom")]: !disabled && dragOverGapBottom
    });
    return /*#__PURE__*/React.createElement("li", _Object$assign({
      className: nodeCls,
      role: "treenode",
      "data-key": eventKey,
      onClick: this.onClick,
      onContextMenu: this.onContextMenu,
      onDoubleClick: this.onDoubleClick,
      ref: this.setRef,
      style: style
    }, dragProps), this.renderArrow(), /*#__PURE__*/React.createElement("span", {
      className: labelCls
    }, multiple ? this.renderCheckbox() : null, this.renderIcon(), /*#__PURE__*/React.createElement("span", {
      className: "".concat(prefixcls, "-label-text")
    }, this.renderRealLabel())));
  }

}
TreeNode.contextType = TreeContext;
TreeNode.propTypes = {
  expanded: PropTypes.bool,
  selected: PropTypes.bool,
  checked: PropTypes.bool,
  halfChecked: PropTypes.bool,
  active: PropTypes.bool,
  disabled: PropTypes.bool,
  loaded: PropTypes.bool,
  loading: PropTypes.bool,
  isLeaf: PropTypes.bool,
  pos: PropTypes.string,
  children: PropTypes.oneOfType([PropTypes.array, PropTypes.object]),
  icon: PropTypes.node,
  directory: PropTypes.bool,
  keyword: PropTypes.string,
  treeNodeFilterProp: PropTypes.string,
  selectedKey: PropTypes.string,
  motionKey: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)])
};
TreeNode.defaultProps = {
  selectedKey: '',
  motionKey: ''
};