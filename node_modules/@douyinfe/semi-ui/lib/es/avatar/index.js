import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && _indexOfInstanceProperty(e).call(e, p) < 0) t[p] = s[p];

  if (s != null && typeof _Object$getOwnPropertySymbols === "function") for (var i = 0, p = _Object$getOwnPropertySymbols(s); i < p.length; i++) {
    if (_indexOfInstanceProperty(e).call(e, p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

import React from 'react';
import cls from 'classnames';
import PropTypes from 'prop-types';
import { cssClasses, strings } from '@douyinfe/semi-foundation/lib/es/avatar/constants';
import AvatarFoundation from '@douyinfe/semi-foundation/lib/es/avatar/foundation';
import '@douyinfe/semi-foundation/lib/es/avatar/avatar.css';
import { noop } from '@douyinfe/semi-foundation/lib/es/utils/function';
import BaseComponent from '../_base/baseComponent';
const sizeSet = strings.SIZE;
const shapeSet = strings.SHAPE;
const colorSet = strings.COLOR;
const prefixCls = cssClasses.PREFIX;
export * from './interface';
export default class Avatar extends BaseComponent {
  constructor(props) {
    var _context, _context2, _context3;

    super(props);
    this.state = {
      isImgExist: true,
      hoverContent: ''
    };
    this.onEnter = _bindInstanceProperty(_context = this.onEnter).call(_context, this);
    this.onLeave = _bindInstanceProperty(_context2 = this.onLeave).call(_context2, this);
    this.handleError = _bindInstanceProperty(_context3 = this.handleError).call(_context3, this);
  }

  get adapter() {
    return _Object$assign(_Object$assign({}, super.adapter), {
      notifyImgState: isImgExist => {
        this.setState({
          isImgExist
        });
      },
      notifyEnter: e => {
        const {
          hoverMask
        } = this.props;
        const hoverContent = hoverMask;
        this.setState({
          hoverContent
        }, () => {
          const {
            onMouseEnter
          } = this.props;
          onMouseEnter && onMouseEnter(e);
        });
      },
      notifyLeave: e => {
        this.setState({
          hoverContent: ''
        }, () => {
          const {
            onMouseLeave
          } = this.props;
          onMouseLeave && onMouseLeave(e);
        });
      }
    });
  }

  componentDidMount() {
    this.foundation = new AvatarFoundation(this.adapter);
    this.foundation.init();
  }

  componentDidUpdate(prevProps) {
    if (this.props.src && this.props.src !== prevProps.src) {
      const image = new Image(0, 0);
      image.src = this.props.src;

      image.onload = () => {
        this.setState({
          isImgExist: true
        });
      };

      image.onerror = () => {
        this.setState({
          isImgExist: false
        });
      };

      image.onabort = () => {
        this.setState({
          isImgExist: false
        });
      };
    }
  }

  componentWillUnmount() {
    this.foundation.destroy();
  }

  onEnter() {
    this.foundation.handleEnter();
  }

  onLeave() {
    this.foundation.handleLeave();
  }

  handleError() {
    this.foundation.handleImgLoadError();
  }

  render() {
    var _context4, _context5, _context6;

    // eslint-disable-next-line max-len, no-unused-vars
    const _a = this.props,
          {
      shape,
      children,
      size,
      color,
      className,
      hoverMask,
      onClick,
      imgAttr,
      src,
      srcSet,
      style,
      alt
    } = _a,
          others = __rest(_a, ["shape", "children", "size", "color", "className", "hoverMask", "onClick", "imgAttr", "src", "srcSet", "style", "alt"]);

    const {
      isImgExist,
      hoverContent
    } = this.state;
    const isImg = src && isImgExist;
    const avatarCls = cls(prefixCls, {
      [_concatInstanceProperty(_context4 = "".concat(prefixCls, "-")).call(_context4, shape)]: shape,
      [_concatInstanceProperty(_context5 = "".concat(prefixCls, "-")).call(_context5, size)]: size,
      [_concatInstanceProperty(_context6 = "".concat(prefixCls, "-")).call(_context6, color)]: color && !isImg,
      ["".concat(prefixCls, "-img")]: isImg
    }, className);
    let content = children;
    const hoverRender = hoverContent ? /*#__PURE__*/React.createElement("div", {
      className: "".concat(prefixCls, "-hover")
    }, hoverContent) : null;

    if (isImg) {
      content = /*#__PURE__*/React.createElement("img", _Object$assign({
        src: src,
        srcSet: srcSet,
        onError: this.handleError,
        alt: alt
      }, imgAttr));
    } else if (typeof children === 'string') {
      content = /*#__PURE__*/React.createElement("span", {
        className: "".concat(prefixCls, "-content")
      }, /*#__PURE__*/React.createElement("span", {
        className: "".concat(prefixCls, "-label")
      }, children));
    }

    return /*#__PURE__*/React.createElement("span", _Object$assign({}, others, {
      style: style,
      className: avatarCls,
      onClick: onClick,
      onMouseEnter: this.onEnter,
      onMouseLeave: this.onLeave
    }), content, hoverRender);
  }

}
Avatar.defaultProps = {
  size: 'medium',
  color: 'grey',
  shape: 'circle',
  onClick: noop,
  onMouseEnter: noop,
  onMouseLeave: noop
};
Avatar.propTypes = {
  children: PropTypes.node,
  color: PropTypes.oneOf(colorSet),
  shape: PropTypes.oneOf(shapeSet),
  size: PropTypes.oneOf(sizeSet),
  hoverMask: PropTypes.node,
  className: PropTypes.string,
  style: PropTypes.object,
  imgAttr: PropTypes.object,
  src: PropTypes.string,
  srcSet: PropTypes.string,
  alt: PropTypes.string,
  onError: PropTypes.func,
  onClick: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func
};