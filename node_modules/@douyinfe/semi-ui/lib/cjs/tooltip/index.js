"use strict";

var _WeakMap = require("@babel/runtime-corejs3/core-js-stable/weak-map");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/includes"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _each2 = _interopRequireDefault(require("lodash/each"));

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _noop2 = _interopRequireDefault(require("lodash/noop"));

var _throttle2 = _interopRequireDefault(require("lodash/throttle"));

var _react = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _constants = require("@douyinfe/semi-foundation/lib/cjs/base/constants");

var _warning = _interopRequireDefault(require("@douyinfe/semi-foundation/lib/cjs/utils/warning"));

var _Event = _interopRequireDefault(require("@douyinfe/semi-foundation/lib/cjs/utils/Event"));

var _dom = require("@douyinfe/semi-foundation/lib/cjs/utils/dom");

var _foundation = _interopRequireDefault(require("@douyinfe/semi-foundation/lib/cjs/tooltip/foundation"));

var _constants2 = require("@douyinfe/semi-foundation/lib/cjs/tooltip/constants");

require("@douyinfe/semi-foundation/lib/cjs/tooltip/tooltip.css");

var _baseComponent = _interopRequireDefault(require("../_base/baseComponent"));

var _reactUtils = require("../_base/reactUtils");

var _utils = require("../_utils");

var _index = _interopRequireDefault(require("../_portal/index"));

var _context2 = _interopRequireDefault(require("../configProvider/context"));

var _TriangleArrow = _interopRequireDefault(require("./TriangleArrow"));

var _TriangleArrowVertical = _interopRequireDefault(require("./TriangleArrowVertical"));

var _TooltipStyledTransition = _interopRequireDefault(require("./TooltipStyledTransition"));

var _ArrowBoundingShape = _interopRequireDefault(require("./ArrowBoundingShape"));

function _getRequireWildcardCache(nodeInterop) { if (typeof _WeakMap !== "function") return null; var cacheBabelInterop = new _WeakMap(); var cacheNodeInterop = new _WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? _Object$getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { _Object$defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && (0, _indexOf.default)(e).call(e, p) < 0) t[p] = s[p];

  if (s != null && typeof _getOwnPropertySymbols.default === "function") for (var i = 0, p = (0, _getOwnPropertySymbols.default)(s); i < p.length; i++) {
    if ((0, _indexOf.default)(e).call(e, p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
/* eslint-disable prefer-destructuring, max-lines-per-function, react/no-find-dom-node, max-len, @typescript-eslint/no-empty-function */


const prefix = _constants2.cssClasses.PREFIX;
const positionSet = _constants2.strings.POSITION_SET;
const triggerSet = _constants2.strings.TRIGGER_SET;
const blockDisplays = ['flex', 'block', 'table', 'flow-root', 'grid'];

const defaultGetContainer = () => document.body;

class Tooltip extends _baseComponent.default {
  constructor(props) {
    super(props);

    this.setContainerEl = node => this.containerEl = {
      current: node
    };

    this.isSpecial = elem => {
      if ((0, _reactUtils.isHTMLElement)(elem)) {
        return Boolean(elem.disabled);
      } else if ( /*#__PURE__*/(0, _react.isValidElement)(elem)) {
        const disabled = (0, _get2.default)(elem, 'props.disabled');

        if (disabled) {
          return _constants2.strings.STATUS_DISABLED;
        }

        const loading = (0, _get2.default)(elem, 'props.loading');
        /* Only judge the loading state of the Button, and no longer judge other components */

        const isButton = !(0, _isEmpty2.default)(elem) && !(0, _isEmpty2.default)(elem.type) && elem.type.name === 'Button' || elem.type.name === 'IconButton';

        if (loading && isButton) {
          return _constants2.strings.STATUS_LOADING;
        }
      }

      return false;
    };

    this.willEnter = () => {
      this.foundation.calcPosition();
      /**
       * Dangerous: remove setState in motion fix #1379
       * because togglePortalVisible callback function will use visible state to notifyVisibleChange
       * if visible state is old value, then notifyVisibleChange function will not be called
       * we should ensure that after calling togglePortalVisible, callback function can get right visible value
       */
      // this.setState({ visible: true });
    };

    this.didLeave = () => {
      this.adapter.unregisterClickOutsideHandler();
      this.adapter.unregisterScrollHandler();
      this.adapter.unregisterResizeHandler();
      this.adapter.removePortal();
    };

    this.renderIcon = () => {
      const {
        placement
      } = this.state;
      const {
        showArrow,
        prefixCls,
        style
      } = this.props;
      let icon = null;
      const triangleCls = (0, _classnames.default)(["".concat(prefixCls, "-icon-arrow")]);
      const bgColor = (0, _get2.default)(style, 'backgroundColor');
      const iconComponent = (0, _includes.default)(placement).call(placement, 'left') || (0, _includes.default)(placement).call(placement, 'right') ? /*#__PURE__*/_react.default.createElement(_TriangleArrowVertical.default, null) : /*#__PURE__*/_react.default.createElement(_TriangleArrow.default, null);

      if (showArrow) {
        if ( /*#__PURE__*/(0, _react.isValidElement)(showArrow)) {
          icon = showArrow;
        } else {
          icon = /*#__PURE__*/_react.default.cloneElement(iconComponent, {
            className: triangleCls,
            style: {
              color: bgColor,
              fill: 'currentColor'
            }
          });
        }
      }

      return icon;
    };

    this.handlePortalInnerClick = e => {
      if (this.props.clickToHide) {
        this.foundation.hide();
      }

      if (this.props.stopPropagation) {
        (0, _utils.stopPropagation)(e);
      }
    };

    this.renderPortal = () => {
      const {
        containerStyle = {},
        visible,
        portalEventSet,
        placement,
        transitionState
      } = this.state;
      const {
        prefixCls,
        content,
        showArrow,
        style,
        motion,
        zIndex
      } = this.props;
      const {
        className: propClassName
      } = this.props;
      const direction = this.context.direction;
      const className = (0, _classnames.default)(propClassName, {
        ["".concat(prefixCls, "-wrapper")]: true,
        ["".concat(prefixCls, "-wrapper-show")]: visible,
        ["".concat(prefixCls, "-with-arrow")]: Boolean(showArrow),
        ["".concat(prefixCls, "-rtl")]: direction === 'rtl'
      });
      const icon = this.renderIcon();
      const portalInnerStyle = (0, _omit2.default)(containerStyle, motion ? ['transformOrigin'] : undefined);
      const transformOrigin = (0, _get2.default)(containerStyle, 'transformOrigin');
      const inner = motion ? /*#__PURE__*/_react.default.createElement(_TooltipStyledTransition.default, {
        position: placement,
        willEnter: this.willEnter,
        didLeave: this.didLeave,
        motion: motion
      }, transitionState === 'enter' ? _ref => {
        let {
          animateCls,
          animateStyle,
          animateEvents
        } = _ref;
        return /*#__PURE__*/_react.default.createElement("div", (0, _assign.default)({
          className: (0, _classnames.default)(className, animateCls),
          style: (0, _assign.default)((0, _assign.default)((0, _assign.default)({
            visibility: 'visible'
          }, animateStyle), {
            transformOrigin
          }), style)
        }, portalEventSet, animateEvents, {
          "x-placement": placement
        }), content, icon);
      } : null) : /*#__PURE__*/_react.default.createElement("div", (0, _assign.default)({
        className: className
      }, portalEventSet, {
        "x-placement": placement,
        style: style
      }), content, icon);
      return /*#__PURE__*/_react.default.createElement(_index.default, {
        getPopupContainer: this.props.getPopupContainer,
        style: {
          zIndex
        }
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "".concat(_constants.BASE_CLASS_PREFIX, "-portal-inner"),
        style: portalInnerStyle,
        ref: this.setContainerEl,
        onClick: this.handlePortalInnerClick
      }, inner));
    };

    this.wrapSpan = elem => {
      const {
        wrapperClassName
      } = this.props;
      const display = (0, _get2.default)(elem, 'props.style.display');
      const block = (0, _get2.default)(elem, 'props.block');
      const style = {
        display: 'inline-block'
      };

      if (block || (0, _includes.default)(blockDisplays).call(blockDisplays, display)) {
        style.width = '100%';
      }

      return /*#__PURE__*/_react.default.createElement("span", {
        className: wrapperClassName,
        style: style
      }, elem);
    };

    this.mergeEvents = (rawEvents, events) => {
      const mergedEvents = {};
      (0, _each2.default)(events, (handler, key) => {
        if (typeof handler === 'function') {
          mergedEvents[key] = function () {
            handler(...arguments);

            if (rawEvents && typeof rawEvents[key] === 'function') {
              rawEvents[key](...arguments);
            }
          };
        }
      });
      return mergedEvents;
    };

    this.state = {
      visible: false,

      /**
       *
       * Note: The transitionState parameter is equivalent to isInsert
       */
      transitionState: '',
      triggerEventSet: {},
      portalEventSet: {},
      containerStyle: {// zIndex: props.zIndex,
      },
      isInsert: false,
      placement: props.position || 'top',
      transitionStyle: {}
    };
    this.foundation = new _foundation.default(this.adapter);
    this.eventManager = new _Event.default();
    this.triggerEl = /*#__PURE__*/_react.default.createRef();
    this.containerEl = /*#__PURE__*/_react.default.createRef();
    this.clickOutsideHandler = null;
    this.resizeHandler = null;
    this.isWrapped = false; // Identifies whether a span element is wrapped

    this.containerPosition = undefined;
  }

  get adapter() {
    var _this = this;

    return (0, _assign.default)((0, _assign.default)({}, super.adapter), {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      on: function () {
        return _this.eventManager.on(...arguments);
      },
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      off: function () {
        return _this.eventManager.off(...arguments);
      },
      insertPortal: (content, _a) => {
        var {
          position
        } = _a,
            containerStyle = __rest(_a, ["position"]);

        this.setState({
          isInsert: true,
          transitionState: 'enter',
          containerStyle: (0, _assign.default)((0, _assign.default)({}, this.state.containerStyle), containerStyle)
        }, () => {
          /**
           * Dangerous: remove setTimeout from here fix #1301
           * setTimeout may emit portalInserted event after hiding portal
           * Hiding portal will remove portalInserted event listener(normal process)
           * then portal can't hide because _togglePortalVisible(false) will found isVisible=false and nowVisible=false(bug here)
           */
          this.eventManager.emit('portalInserted');
        });
      },
      removePortal: () => {
        this.setState({
          isInsert: false
        });
      },
      getEventName: () => ({
        mouseEnter: 'onMouseEnter',
        mouseLeave: 'onMouseLeave',
        mouseOut: 'onMouseOut',
        mouseOver: 'onMouseOver',
        click: 'onClick',
        focus: 'onFocus',
        blur: 'onBlur'
      }),
      registerTriggerEvent: triggerEventSet => {
        this.setState({
          triggerEventSet
        });
      },
      unregisterTriggerEvent: () => {},
      registerPortalEvent: portalEventSet => {
        this.setState({
          portalEventSet
        });
      },
      unregisterPortalEvent: () => {},
      getTriggerBounding: () => {
        // eslint-disable-next-line
        // It may be a React component or an html element
        // There is no guarantee that triggerE l.current can get the real dom, so call findDOMNode to ensure that you can get the real dom
        let triggerDOM = this.triggerEl.current;

        if (!(0, _reactUtils.isHTMLElement)(this.triggerEl.current)) {
          const realDomNode = _reactDom.default.findDOMNode(this.triggerEl.current);

          this.triggerEl.current = realDomNode;
          triggerDOM = realDomNode;
        }

        return triggerDOM && triggerDOM.getBoundingClientRect();
      },
      // Gets the outer size of the specified container
      getPopupContainerRect: () => {
        const container = this.getPopupContainer();
        let rect = null;

        if (container && (0, _reactUtils.isHTMLElement)(container)) {
          const boundingRect = (0, _dom.convertDOMRectToObject)(container.getBoundingClientRect());
          rect = (0, _assign.default)((0, _assign.default)({}, boundingRect), {
            scrollLeft: container.scrollLeft,
            scrollTop: container.scrollTop
          });
        }

        return rect;
      },
      containerIsBody: () => {
        const container = this.getPopupContainer();
        return container === document.body;
      },
      containerIsRelative: () => {
        const container = this.getPopupContainer();
        const computedStyle = window.getComputedStyle(container);
        return computedStyle.getPropertyValue('position') === 'relative';
      },
      containerIsRelativeOrAbsolute: () => {
        var _context;

        return (0, _includes.default)(_context = ['relative', 'absolute']).call(_context, this.containerPosition);
      },
      // Get the size of the pop-up layer
      getWrapperBounding: () => {
        const el = this.containerEl && this.containerEl.current;
        return el && el.getBoundingClientRect();
      },
      getDocumentElementBounding: () => document.documentElement.getBoundingClientRect(),
      setPosition: _a => {
        var {
          position
        } = _a,
            style = __rest(_a, ["position"]);

        this.setState({
          containerStyle: (0, _assign.default)((0, _assign.default)({}, this.state.containerStyle), style),
          placement: position
        }, () => {
          this.eventManager.emit('positionUpdated');
        });
      },
      updatePlacementAttr: placement => {
        this.setState({
          placement
        });
      },
      togglePortalVisible: (visible, cb) => {
        const willUpdateStates = {};

        if (this.adapter.canMotion()) {
          willUpdateStates.transitionState = visible ? 'enter' : 'leave';
          willUpdateStates.visible = visible;
        } else {
          willUpdateStates.visible = visible;
        }

        this.setState(willUpdateStates, () => {
          cb();
        });
      },
      registerClickOutsideHandler: cb => {
        if (this.clickOutsideHandler) {
          this.adapter.unregisterClickOutsideHandler();
        }

        this.clickOutsideHandler = e => {
          if (!this.mounted) {
            return false;
          }

          let el = this.triggerEl && this.triggerEl.current;
          let popupEl = this.containerEl && this.containerEl.current;
          el = _reactDom.default.findDOMNode(el);
          popupEl = _reactDom.default.findDOMNode(popupEl);

          if (el && !el.contains(e.target) && popupEl && !popupEl.contains(e.target) || this.props.clickTriggerToHide) {
            this.props.onClickOutSide(e);
            cb();
          }
        };

        document.addEventListener('click', this.clickOutsideHandler, false);
      },
      unregisterClickOutsideHandler: () => {
        if (this.clickOutsideHandler) {
          document.removeEventListener('click', this.clickOutsideHandler, false);
          this.clickOutsideHandler = null;
        }
      },
      registerResizeHandler: cb => {
        if (this.resizeHandler) {
          this.adapter.unregisterResizeHandler();
        }

        this.resizeHandler = (0, _throttle2.default)(e => {
          if (!this.mounted) {
            return false;
          }

          cb(e);
        }, 10);
        window.addEventListener('resize', this.resizeHandler, false);
      },
      unregisterResizeHandler: () => {
        if (this.resizeHandler) {
          window.removeEventListener('resize', this.resizeHandler, false);
          this.resizeHandler = null;
        }
      },
      notifyVisibleChange: visible => {
        this.props.onVisibleChange(visible);
      },
      registerScrollHandler: rePositionCb => {
        if (this.scrollHandler) {
          this.adapter.unregisterScrollHandler();
        }

        this.scrollHandler = (0, _throttle2.default)(e => {
          if (!this.mounted) {
            return false;
          }

          let triggerDOM = this.triggerEl.current;

          if (!(0, _reactUtils.isHTMLElement)(this.triggerEl.current)) {
            triggerDOM = _reactDom.default.findDOMNode(this.triggerEl.current);
          }

          const isRelativeScroll = e.target.contains(triggerDOM);

          if (isRelativeScroll) {
            const scrollPos = {
              x: e.target.scrollLeft,
              y: e.target.scrollTop
            };
            rePositionCb(scrollPos);
          }
        }, 10); // When it is greater than 16ms, it will be very obvious

        window.addEventListener('scroll', this.scrollHandler, true);
      },
      unregisterScrollHandler: () => {
        if (this.scrollHandler) {
          window.removeEventListener('scroll', this.scrollHandler, true);
          this.scrollHandler = null;
        }
      },
      canMotion: () => Boolean(this.props.motion),
      updateContainerPosition: () => {
        const container = this.getPopupContainer();

        if (container && (0, _reactUtils.isHTMLElement)(container)) {
          // getComputedStyle need first parameter is Element type
          const computedStyle = window.getComputedStyle(container);
          const position = computedStyle.getPropertyValue('position');
          this.containerPosition = position;
        }
      },
      getContainerPosition: () => this.containerPosition
    });
  }

  componentDidMount() {
    this.mounted = true;
    this.getPopupContainer = this.props.getPopupContainer || this.context.getPopupContainer || defaultGetContainer;
    this.foundation.init();
  }

  componentWillUnmount() {
    this.mounted = false;
    this.foundation.destroy();
  }
  /** for transition - end */


  rePosition() {
    return this.foundation.calcPosition();
  }

  componentDidUpdate(prevProps, prevState) {
    (0, _warning.default)(this.props.mouseLeaveDelay < this.props.mouseEnterDelay, "[Semi Tooltip] 'mouseLeaveDelay' cannot be less than 'mouseEnterDelay', which may cause the dropdown layer to not be hidden.");

    if (prevProps.visible !== this.props.visible) {
      this.props.visible ? this.foundation.delayShow() : this.foundation.delayHide();
    }

    if (prevProps.rePosKey !== this.props.rePosKey) {
      this.rePosition();
    }
  }

  render() {
    const {
      isInsert,
      triggerEventSet
    } = this.state;
    const {
      wrapWhenSpecial
    } = this.props;
    let {
      children
    } = this.props;
    const childrenStyle = (0, _assign.default)({}, (0, _get2.default)(children, 'props.style'));
    const extraStyle = {};

    if (wrapWhenSpecial) {
      const isSpecial = this.isSpecial(children);

      if (isSpecial) {
        childrenStyle.pointerEvents = 'none';

        if (isSpecial === _constants2.strings.STATUS_DISABLED) {
          extraStyle.cursor = 'not-allowed';
        }

        children = /*#__PURE__*/(0, _react.cloneElement)(children, {
          style: childrenStyle
        });
        children = this.wrapSpan(children);
        this.isWrapped = true;
      } else if (! /*#__PURE__*/(0, _react.isValidElement)(children)) {
        children = this.wrapSpan(children);
        this.isWrapped = true;
      }
    } // The incoming children is a single valid element, otherwise wrap a layer with span


    const newChild = /*#__PURE__*/_react.default.cloneElement(children, (0, _assign.default)((0, _assign.default)((0, _assign.default)({}, children.props), this.mergeEvents(children.props, triggerEventSet)), {
      style: (0, _assign.default)((0, _assign.default)({}, (0, _get2.default)(children, 'props.style')), extraStyle),
      className: (0, _classnames.default)((0, _get2.default)(children, 'props.className') // `${prefixCls}-trigger`
      ),
      // to maintain refs with callback
      ref: node => {
        // Keep your own reference
        this.triggerEl.current = node; // Call the original ref, if any

        const {
          ref
        } = children; // this.log('tooltip render() - get ref', ref);

        if (typeof ref === 'function') {
          ref(node);
        } else if (ref && typeof ref === 'object') {
          ref.current = node;
        }
      }
    })); // If you do not add a layer of div, in order to bind the events and className in the tooltip, you need to cloneElement children, but this time it may overwrite the children's original ref reference
    // So if the user adds ref to the content, you need to use callback ref: https://github.com/facebook/react/issues/8873


    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, isInsert ? this.renderPortal() : null, newChild);
  }

}

exports.default = Tooltip;
Tooltip.contextType = _context2.default;
Tooltip.propTypes = {
  children: _propTypes.default.node,
  motion: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.object, _propTypes.default.func]),
  autoAdjustOverflow: _propTypes.default.bool,
  position: _propTypes.default.oneOf(positionSet),
  getPopupContainer: _propTypes.default.func,
  mouseEnterDelay: _propTypes.default.number,
  mouseLeaveDelay: _propTypes.default.number,
  trigger: _propTypes.default.oneOf(triggerSet).isRequired,
  className: _propTypes.default.string,
  wrapperClassName: _propTypes.default.string,
  clickToHide: _propTypes.default.bool,
  // used with trigger === hover, private
  clickTriggerToHide: _propTypes.default.bool,
  visible: _propTypes.default.bool,
  style: _propTypes.default.object,
  content: _propTypes.default.node,
  prefixCls: _propTypes.default.string,
  onVisibleChange: _propTypes.default.func,
  onClickOutSide: _propTypes.default.func,
  spacing: _propTypes.default.number,
  showArrow: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.node]),
  zIndex: _propTypes.default.number,
  rePosKey: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
  arrowBounding: _ArrowBoundingShape.default,
  transformFromCenter: _propTypes.default.bool,
  arrowPointAtCenter: _propTypes.default.bool,
  stopPropagation: _propTypes.default.bool,
  // private
  wrapWhenSpecial: _propTypes.default.bool // when trigger has special status such as "disabled" or "loading", wrap span

};
Tooltip.defaultProps = {
  transformFromCenter: true,
  arrowPointAtCenter: true,
  wrapWhenSpecial: true,
  motion: true,
  zIndex: _constants2.numbers.DEFAULT_Z_INDEX,
  trigger: 'hover',
  position: 'top',
  prefixCls: prefix,
  autoAdjustOverflow: true,
  mouseEnterDelay: _constants2.numbers.MOUSE_ENTER_DELAY,
  mouseLeaveDelay: _constants2.numbers.MOUSE_LEAVE_DELAY,
  onVisibleChange: _noop2.default,
  onClickOutSide: _noop2.default,
  spacing: _constants2.numbers.SPACING,
  showArrow: true,
  arrowBounding: _constants2.numbers.ARROW_BOUNDING
};